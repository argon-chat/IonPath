//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a code generation tool.
//     Changes to this file may cause incorrect behavior and will be lost
//     if the code is regenerated.
//
//     Generator: IonPath Codegen
// </auto-generated>
//------------------------------------------------------------------------------

#pragma warning disable
#nullable enable


namespace TestContracts;

[GeneratedCodeAttribute("ionc", null), CompilerGeneratedAttribute]
public sealed class Ion_MathInteraction_ClientImpl(IonClientContext context) : IMathInteraction
{
    
    private static readonly Lazy<MethodInfo> Add_Ref = new(() =>
        typeof(IMathInteraction).GetMethod(nameof(Add), BindingFlags.Public | BindingFlags.Instance)!);
    private static readonly Lazy<MethodInfo> Mul_Ref = new(() =>
        typeof(IMathInteraction).GetMethod(nameof(Mul), BindingFlags.Public | BindingFlags.Instance)!);
    private static readonly Lazy<MethodInfo> Sub_Ref = new(() =>
        typeof(IMathInteraction).GetMethod(nameof(Sub), BindingFlags.Public | BindingFlags.Instance)!);
    private static readonly Lazy<MethodInfo> Div_Ref = new(() =>
        typeof(IMathInteraction).GetMethod(nameof(Div), BindingFlags.Public | BindingFlags.Instance)!);
    private static readonly Lazy<MethodInfo> Pow_Ref = new(() =>
        typeof(IMathInteraction).GetMethod(nameof(Pow), BindingFlags.Public | BindingFlags.Instance)!);
    private static readonly Lazy<MethodInfo> PowArray_Ref = new(() =>
        typeof(IMathInteraction).GetMethod(nameof(PowArray), BindingFlags.Public | BindingFlags.Instance)!);


    
    [GeneratedCodeAttribute("ionc", null), CompilerGeneratedAttribute]
    public async Task<i4> Add(i4 __leftoperand, i4 __rightoperand)
    {
        var req = new IonRequest(context, typeof(IMathInteraction), Add_Ref.Value);
    
        var writer = new CborWriter();
        
        const int argsSize = 2;
    
        writer.WriteStartArray(argsSize);
        
        IonFormatterStorage<i4>.Write(writer, __leftoperand);
        IonFormatterStorage<i4>.Write(writer, __rightoperand);
        
        writer.WriteEndArray();
    
        return await req.CallAsync<i4>(writer.Encode());
    }
    [GeneratedCodeAttribute("ionc", null), CompilerGeneratedAttribute]
    public async Task<i4> Mul(i4 __leftoperand, i4 __rightoperand)
    {
        var req = new IonRequest(context, typeof(IMathInteraction), Mul_Ref.Value);
    
        var writer = new CborWriter();
        
        const int argsSize = 2;
    
        writer.WriteStartArray(argsSize);
        
        IonFormatterStorage<i4>.Write(writer, __leftoperand);
        IonFormatterStorage<i4>.Write(writer, __rightoperand);
        
        writer.WriteEndArray();
    
        return await req.CallAsync<i4>(writer.Encode());
    }
    [GeneratedCodeAttribute("ionc", null), CompilerGeneratedAttribute]
    public async Task<i4> Sub(i4 __leftoperand, i4 __rightoperand)
    {
        var req = new IonRequest(context, typeof(IMathInteraction), Sub_Ref.Value);
    
        var writer = new CborWriter();
        
        const int argsSize = 2;
    
        writer.WriteStartArray(argsSize);
        
        IonFormatterStorage<i4>.Write(writer, __leftoperand);
        IonFormatterStorage<i4>.Write(writer, __rightoperand);
        
        writer.WriteEndArray();
    
        return await req.CallAsync<i4>(writer.Encode());
    }
    [GeneratedCodeAttribute("ionc", null), CompilerGeneratedAttribute]
    public async Task<i4> Div(i4 __leftoperand, i4 __rightoperand)
    {
        var req = new IonRequest(context, typeof(IMathInteraction), Div_Ref.Value);
    
        var writer = new CborWriter();
        
        const int argsSize = 2;
    
        writer.WriteStartArray(argsSize);
        
        IonFormatterStorage<i4>.Write(writer, __leftoperand);
        IonFormatterStorage<i4>.Write(writer, __rightoperand);
        
        writer.WriteEndArray();
    
        return await req.CallAsync<i4>(writer.Encode());
    }
    [GeneratedCodeAttribute("ionc", null), CompilerGeneratedAttribute]
    public async Task<i4> Pow(i4 __leftoperand, i4 __rightoperand)
    {
        var req = new IonRequest(context, typeof(IMathInteraction), Pow_Ref.Value);
    
        var writer = new CborWriter();
        
        const int argsSize = 2;
    
        writer.WriteStartArray(argsSize);
        
        IonFormatterStorage<i4>.Write(writer, __leftoperand);
        IonFormatterStorage<i4>.Write(writer, __rightoperand);
        
        writer.WriteEndArray();
    
        return await req.CallAsync<i4>(writer.Encode());
    }
    [GeneratedCodeAttribute("ionc", null), CompilerGeneratedAttribute]
    public async Task<IonArray<i4>> PowArray(i4 __leftoperand, IonArray<i4> __rightoperand)
    {
        var req = new IonRequest(context, typeof(IMathInteraction), PowArray_Ref.Value);
    
        var writer = new CborWriter();
        
        const int argsSize = 2;
    
        writer.WriteStartArray(argsSize);
        
        IonFormatterStorage<i4>.Write(writer, __leftoperand);
        IonFormatterStorage<i4>.WriteArray(writer, __rightoperand);
        
        writer.WriteEndArray();
    
        return await req.CallAsyncWithArray<i4>(writer.Encode());
    }

}

[GeneratedCodeAttribute("ionc", null), CompilerGeneratedAttribute]
public sealed class Ion_RandomStreamInteraction_ClientImpl(IonClientContext context) : IRandomStreamInteraction
{
    
    private static readonly Lazy<MethodInfo> Integer_Ref = new(() =>
        typeof(IRandomStreamInteraction).GetMethod(nameof(Integer), BindingFlags.Public | BindingFlags.Instance)!);


    
    public IAsyncEnumerable<i4> Integer(i4 __seed)
    {
        var ws = new IonWsClient(context, typeof(IRandomStreamInteraction), Integer_Ref.Value);
    
        var writer = new CborWriter();

        const int argsSize = 1;
        
        writer.WriteStartArray(argsSize);
        
        IonFormatterStorage<i4>.Write(writer, __seed);
        
        writer.WriteEndArray();
    
        return ws.CallServerStreamingAsync<i4>(writer.Encode());
    }

}

