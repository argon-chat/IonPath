namespace ion.compiler.CodeGen;

using ion.runtime;
using Microsoft.Build.Construction;
using Microsoft.Build.Evaluation;
using Pidgin;
using syntax;
using System.Formats.Cbor;
using System.Linq;
using System.Reflection.PortableExecutable;
using System.Text;
using static ion.compiler.CodeGen.IonCSharpGenerator;

public class IonProject
{
    public required string Name { get; set; }

    public IonProjectCSharpSettings? Dotnet { get; set; }


    public class IonProjectCSharpSettings
    {
        public string TargetFramework { get; set; } = "net9.0";

        public string IonRuntimeVersion { get; set; } = "0.0.1";

        public required DirectoryInfo OutputPath { get; set; }
    }
}

public static class FileEx
{
    public static FileInfo File(this DirectoryInfo directory, string file) =>
        new(Path.Combine(directory.FullName, file));

    public static DirectoryInfo Directory(this DirectoryInfo directory, string dir) =>
        new(Path.Combine(directory.FullName, dir));

    public static DirectoryInfo Combine(this DirectoryInfo directory, string atFolder)
    {
        if (atFolder.StartsWith("@"))
            return new DirectoryInfo(Path.Combine(directory.FullName, atFolder.Replace("@", ".")));
        return new DirectoryInfo(atFolder);
    }
}

public static class IonCSharpGeneratorEx
{
    private static readonly string CompileGenerateAttributes = // {compileGeneratedAttributes}
        "[GeneratedCodeAttribute(\"ionc\", null), CompilerGeneratedAttribute]";

    public static string ToCompiledString(this StringBuilder builder)
        => builder.ToString().Replace("{compileGeneratedAttributes}", CompileGenerateAttributes);
}

public interface IIonCodeGenerator
{
    void GenerateProjectFile(string projectName, FileInfo outputFile);


    string GenerateModuleInit(IEnumerable<IonType> types, IReadOnlyList<IonService> services, bool clientToo,
        bool serverToo);

    string GenerateModule(IonModule module);

    string GenerateAllServiceExecutors(IEnumerable<IonService> service);

    string GenerateAllServiceClientImpl(IEnumerable<IonService> service);

    string GenerateGlobalTypes();
}

public class IonCSharpGenerator(string @namespace) : IIonCodeGenerator
{
    private string FileHeader()
    {
        return $"""
                //------------------------------------------------------------------------------
                // <auto-generated>
                //     This code was generated by a code generation tool.
                //     Changes to this file may cause incorrect behavior and will be lost
                //     if the code is regenerated.
                //
                //     Generator: IonPath Codegen
                // </auto-generated>
                //------------------------------------------------------------------------------

                #pragma warning disable
                #nullable enable


                namespace {@namespace};
                """;
    }

    private static readonly string ModuleInitTemplate =
        """
        {compileGeneratedAttributes}
        internal static class IonProjectFormatterStorageModuleInit
        {
            [ModuleInitializer]
            internal static void Init()
            {
                {formatters}
            }
        }
        """;

    public string GenerateModuleInit(IEnumerable<IonType> types, IReadOnlyList<IonService> services, bool clientToo,
        bool serverToo)
    {
        var candidates = types.Where(t => t is { IsBuiltin: false, IsScalar: false, IsVoid: false }).ToArray();
        var sorted = TopoSortByDependencies(candidates);

        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());

        var formattersSb = new StringBuilder();

        formattersSb.AppendLine();

        foreach (var t in sorted) 
            formattersSb.AppendLine($"      IonFormatterStorage<{UnwrapType(t)}>.Value = new Ion_{UnwrapType(t)}_Formatter();");

        foreach (var t in candidates.Where(x => x.IsUnion).OfType<IonUnion>().SelectMany(x => x.types).Where(x => x.IsUnionCase))
            formattersSb.AppendLine($"      IonFormatterStorage<{UnwrapType(t)}>.Value = new Ion_{UnwrapType(t)}_Formatter();");

        if (serverToo)
        {
            foreach (var service in services)
            {
                var typeName = service.name.Identifier;
                formattersSb.AppendLine(
                    $"      IonExecutorMetadataStorage.AddExecutor<Ion_{typeName}_ServiceExecutor>(\"I{typeName}\");");
            }
        }

        if (clientToo)
        {
            foreach (var service in services)
            {
                var typeName = service.name.Identifier;
                formattersSb.AppendLine(
                    $"      IonExecutorMetadataStorage.AddClient<Ion_{typeName}_ClientImpl>(\"I{typeName}\");");
            }
        }


        sb.AppendLine(ModuleInitTemplate.Replace("{formatters}", formattersSb.ToString()));

        return sb.ToCompiledString();
    }

    public void GenerateProjectFile(string projectName, FileInfo outputFile)
    {
        var project = ProjectRootElement.Create(NewProjectFileOptions.None);
        project.Sdk = "Microsoft.NET.Sdk";

        var propertyGroup = project.AddPropertyGroup();
        propertyGroup.AddProperty("OutputType", "Library");
        propertyGroup.AddProperty("TargetFramework", "net9.0");
        propertyGroup.AddProperty("ImplicitUsings", "enable");
        propertyGroup.AddProperty("RootNamespace", projectName);

        var itemGroup = project.AddItemGroup();
        itemGroup.AddItem("PackageReference", "ion.runtime")
            .AddMetadata("Version", "1.0.0-beta.1", expressAsAttribute: true);
        itemGroup.AddItem("PackageReference", "ion.runtime.network")
            .AddMetadata("Version", "1.0.0-beta.1", expressAsAttribute: true);

        project.Save(outputFile.FullName);
    }


    public string GenerateGlobalTypes() =>
        """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a code generation tool.
        //     Changes to this file may cause incorrect behavior and will be lost
        //     if the code is regenerated.
        //
        //     Generator: IonPath Codegen
        // </auto-generated>
        //------------------------------------------------------------------------------

        #pragma warning disable

        global using i1 = System.SByte;
        global using i2 = System.Int16;
        global using i4 = System.Int32;
        global using i8 = System.Int64;
        global using i16 = System.Int128;

        global using u1 = System.Byte;
        global using u2 = System.UInt16;
        global using u4 = System.UInt32;
        global using u8 = System.UInt64;
        global using u16 = System.UInt128;

        global using f2 = System.Half;
        global using f4 = System.Single;
        global using f8 = System.Double;
        global using guid = System.Guid;
        global using dateonly = System.DateOnly;
        global using timeonly = System.TimeOnly;
        global using duration = System.TimeSpan;
        global using datetime = System.DateTime;

        global using System.CodeDom.Compiler;
        global using System.Runtime.CompilerServices;

        global using System.Formats.Cbor;
        global using ion.runtime;
        global using ion.runtime.network;
        global using Microsoft.Extensions.DependencyInjection;
        global using System.Diagnostics;
        global using System.Reflection;
        global using ion.runtime.client;
        global using System.Buffers;
        """;

    public string GenerateModule(IonModule module)
    {
        var sb = new StringBuilder();
        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var type in module.Definitions.Where(type => type is { IsUnionCase: false, IsUnion: false }))
        {
            sb.AppendLine(GenerateType(type));
            sb.AppendLine();
        }

        foreach (var service in module.Services)
        {
            sb.AppendLine(GenerateService(service));
            sb.AppendLine();
        }

        foreach (var union in module.Definitions.OfType<IonUnion>())
        {
            sb.AppendLine(GenerateUnion(union));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }

    private static string GenerateType(IonType type)
    {
        if (type is IonEnum enumType)
            return GenerateEnum(enumType);
        if (type is IonFlags flagsType)
            return GenerateFlags(flagsType);
        if (type is IonGenericType)
            return null;
        if (type.isTypedef)
            return GenerateTypedef(type);
        return GenerateMessage(type);
    }

    private static string GenerateEnum(IonEnum e)
    {
        var sb = new StringBuilder();
        sb.AppendLine("{compileGeneratedAttributes}");
        sb.AppendLine($"public enum {e.name.Identifier}");
        sb.AppendLine("{");
        foreach (var m in e.members)
            sb.AppendLine($"    {m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateFlags(IonFlags f)
    {
        var sb = new StringBuilder();
        sb.AppendLine("{compileGeneratedAttributes}");
        sb.AppendLine("[Flags]");
        sb.AppendLine($"public enum {f.name.Identifier} : {UnwrapType(f.baseType)}");
        sb.AppendLine("{");
        foreach (var m in f.members)
            sb.AppendLine($"    {m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateTypedef(IonType type)
    {
        var underlying = ResolveTypeName(type.fields.FirstOrDefault()?.type);
        return "{compileGeneratedAttributes}" +
               $"public readonly record struct {type.name.Identifier}({underlying} Value);";
    }

    private static string GenerateMessage(IonType type)
    {
        var sb = new StringBuilder();
        sb.AppendLine("{compileGeneratedAttributes}");
        sb.Append($"public sealed record {type.name.Identifier}(");
        sb.Append(string.Join(", ", type.fields.Select(f =>
            $"{GenerateField(f)}")));
        sb.AppendLine(");");
        return sb.ToString();
    }

    private static string GenerateService(IonService service)
    {
        var sb = new StringBuilder();
        sb.AppendLine("{compileGeneratedAttributes}");
        sb.AppendLine($"public interface I{service.name.Identifier} : IIonService");
        sb.AppendLine("{");

        foreach (var method in service.methods)
        {
            var args = string.Join(", ", method.arguments.Select(GenerateArgument));
            sb.AppendLine($"    {GenerateReturnType(method)} {method.name.Identifier}({args});");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateField(IonField field) => $"{UnwrapType(field.type)} {field.name.Identifier}";

    private static string GenerateArgument(IonArgument field) => $"{UnwrapType(field.type)} {field.name.Identifier}";

    private static string UnwrapType(IonType type) => type switch
    {
        IonGenericType { IsMaybe: true } maybe => $"IonMaybe<{ResolveTypeName(maybe.TypeArguments[0])}>",
        IonGenericType { IsArray: true } array => $"IonArray<{ResolveTypeName(array.TypeArguments[0])}>",
        IonGenericType generic => GenerateGenericTypeName(generic),
        _ => ResolveTypeName(type)
    };

    private static string GenerateGenericTypeName(IonGenericType generic)
        => $"{generic.name.Identifier}<{string.Join(',', generic.TypeArguments.Select(x => x.name.Identifier))}>";

    private static string ResolveTypeName(IonType type)
    {
        if (type is IonUnion union)
            return $"I{union.name.Identifier}";
        return type.name.Identifier;
    }

    private static string GenerateReturnType(IonMethod method)
    {
        if (method.returnType.IsVoid)
            return "Task";
        if (method.IsStreamable)
            return $"IAsyncEnumerable<{UnwrapType(method.returnType)}>";
        return $"Task<{UnwrapType(method.returnType)}>";
    }

    private string FormatterTemplate =>
        """
        {compileGeneratedAttributes}
        public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
        {
            {compileGeneratedAttributes}
            public {ionType} Read(CborReader reader)
            {
                reader.ReadStartArray();
                {fieldReadExpression}
                reader.ReadEndArray();
                return new({ctorFields});
            }
            
            {compileGeneratedAttributes}
            public void Write(CborWriter writer, {ionType} value)
            {
                writer.WriteStartArray(null);
                {fieldWriteExpression}
                writer.WriteEndArray();
            }
        }
        """;

    private static string FormatterTemplateRef(IonType type)
    {
        if (type.IsVoid)
            throw new InvalidOperationException();
        return $"IonFormatterStorage<{UnwrapType(type)}>";
    }

    public string GenerateAllServiceExecutors(IEnumerable<IonService> service)
    {
        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var ionService in service)
        {
            sb.AppendLine(GenerateServiceExecutor(ionService));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }

    public string GenerateAllServiceClientImpl(IEnumerable<IonService> service)
    {
        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var ionService in service)
        {
            sb.AppendLine(GenerateServiceClientImpl(ionService));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }


    public string GenerateAllFormatters(IEnumerable<IonType> types)
    {
        var candidates = types.Where(t => t is { IsBuiltin: false, IsScalar: false, IsVoid: false, IsUnionCase: false, IsUnion: false }).ToArray();
        var sorted = TopoSortByDependencies(candidates);

        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());

        foreach (var t in sorted)
        {
            sb.AppendLine(GenerateFormatterForType(t));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }

    private static string GenerateFormatterForEnum(IonEnum @enum) =>
        """
            {compileGeneratedAttributes}
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                {compileGeneratedAttributes}
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }
                
                {compileGeneratedAttributes}
                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");

    private static string GenerateFormatterForFlags(IonFlags @enum) =>
        """
            {compileGeneratedAttributes}
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }

                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");


    private string GenerateFormatterForType(IonType type)
    {
        if (type is IonEnum @enum)
            return GenerateFormatterForEnum(@enum);
        if (type is IonFlags flags)
            return GenerateFormatterForFlags(flags);

        var name = type.name.Identifier;

        var template = FormatterTemplate
            .Replace("{ionType}", name)
            .Replace("{fieldReadExpression}", GenerateReadField(type))
            .Replace("{ctorFields}", GenerateCaptureField(type))
            .Replace("{fieldWriteExpression}", GenerateWriteField(type));

        return template;
    }

    private static string GenerateCaptureField(IonType type)
        => string.Join(", ", type.fields.Select(x => $"__{x.name.Identifier.ToLowerInvariant()}"));

    private static string GenerateCaptureField(IonMethod method)
        => string.Join(", ", method.arguments.Select(x => $"__{x.name.Identifier.ToLowerInvariant()}"));

    private static string GenerateReadField(IonType type) =>
        string.Join($"\n{new string(' ', 8)}", type.fields.Select(GenerateReadField));

    private static string GenerateReadField(IonField field) =>
        field switch
        {
            { type: { IsArray: true } } => GenerateReadArrayField(field),
            { type: { IsMaybe: true } } => GenerateReadMaybeField(field),
            _ => $"var __{field.name.Identifier.ToLowerInvariant()} = {FormatterTemplateRef(field.type)}.Read(reader);"
        };

    private static string GenerateReadArgument(IonArgument argument) =>
        argument switch
        {
            { type: { IsArray: true } } => GenerateReadArrayField(argument),
            { type: { IsMaybe: true } } => GenerateReadMaybeField(argument),
            _ =>
                $"var __{argument.name.Identifier.ToLowerInvariant()} = {FormatterTemplateRef(argument.type)}.Read(reader);"
        };


    private static string GenerateWriteArgument(IonArgument argument) =>
        argument switch
        {
            { type: { IsArray: true } } => GenerateWriteArrayField(argument),
            { type: { IsMaybe: true } } => GenerateWriteMaybeField(argument),
            _ =>
                $"{FormatterTemplateRef(argument.type)}.Write(writer, __{argument.name.Identifier.ToLowerInvariant()});"
        };

    private static string GenerateReadArrayField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"var __{field.Name.Identifier.ToLowerInvariant()} = IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.ReadArray(reader);";
    }

    private static string GenerateReadMaybeField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"var __{field.Name.Identifier.ToLowerInvariant()} = IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.ReadMaybe(reader);";
    }


    private static string GenerateWriteArrayField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteArray(writer, __{field.Name.Identifier.ToLowerInvariant()});";
    }

    private static string GenerateWriteMaybeField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteMaybe(writer, __{field.Name.Identifier.ToLowerInvariant()});";
    }

    private static string GenerateWriteReturnValue(IonType returnType) =>
        returnType switch
        {
            { IsArray: true } => GenerateWriteReturnValueForArray(returnType),
            { IsMaybe: true } => GenerateWriteReturnValueForMaybe(returnType),
            _ => $"{FormatterTemplateRef(returnType)}.Write(writer, result);"
        };

    private static string GenerateWriteReturnValueForArray(IonType returnType)
    {
        if (returnType is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return $"{FormatterTemplateRef(arrayType.TypeArguments.First())}.WriteArray(writer, result);";
    }

    private static string GenerateWriteReturnValueForMaybe(IonType returnType)
    {
        if (returnType is not IonGenericType { IsMaybe: true } maybeType)
            throw new InvalidOperationException();
        return $"{FormatterTemplateRef(maybeType.TypeArguments.First())}.WriteMaybe(writer, result);";
    }

    private static string GenerateWriteField(IonType type)
        => string.Join($"\n{new string(' ', 8)}", type.fields.Select(GenerateWriteField));

    private static string GenerateWriteField(IonField field)
    {
        return field switch
        {
            { type: { IsArray: true } } => GenerateWriteArrayField(field),
            { type: { IsMaybe: true } } => GenerateWriteMaybeField(field),
            _ => $"{FormatterTemplateRef(field.type)}.Write(writer, value.{field.name.Identifier});"
        };
    }

    private static string GenerateReadArguments(IonMethod method)
        => string.Join($"\n{new string(' ', 8)}", method.arguments.Select(GenerateReadArgument));

    private static string GenerateWriteArguments(IonMethod method)
        => string.Join($"\n{new string(' ', 8)}", method.arguments.Select(GenerateWriteArgument));

    private static string GenerateWriteArrayField(IonField field)
    {
        if (field.type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteArray(writer, value.{field.name.Identifier});";
    }

    private static string GenerateWriteMaybeField(IonField field)
    {
        if (field.type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteMaybe(writer, value.{field.name.Identifier});";
    }

    private static IReadOnlyList<IonType> TopoSortByDependencies(IReadOnlyList<IonType> types)
    {
        var byName = types.ToDictionary(t => t.name.Identifier, t => t);
        var visited = new HashSet<string>();
        var temp = new HashSet<string>();
        var result = new List<IonType>();

        foreach (var t in types) Visit(t);
        return result;

        void Visit(IonType t)
        {
            var key = t.name.Identifier;
            if (visited.Contains(key)) return;
            if (!temp.Add(key)) return;

            foreach (var f in t.fields ?? [])
            {
                var ft = f.type;
                if (ft is null || ft.IsBuiltin || ft.IsScalar || ft.IsVoid) continue;
                if (byName.TryGetValue(ft.name.Identifier, out var dep))
                    Visit(dep);
            }

            temp.Remove(key);
            visited.Add(key);
            result.Add(t);
        }
    }


    private static readonly string ServiceExecutorTemplate =
        """
        public sealed class Ion_{serviceTypename}_ServiceExecutor(AsyncServiceScope scope) : {routerInterfaces}
        {
            {body}
            
            {routerStreaming}
            
            {routerUnary}
        }
        """;

    private static readonly string RouterStreamMethodTemplate =
        """
            public IAsyncEnumerable<Memory<byte>> StreamRouteExecuteAsync(string methodName, CborReader reader, [EnumeratorCancellation] CancellationToken ct)
            {
                {serviceStreamRouteBranch}
                
                throw new InvalidOperationException("no method defined");
            }
        """;

    private static readonly string RouterMethodTemplate =
        """
            public Task RouteExecuteAsync(string methodName, CborReader reader, CborWriter writer)
            {
                {serviceRouteBranch}
                
                throw new InvalidOperationException("no method defined");
            }
        """;

    private static readonly string ServiceStreamExecutorMethodTemplate =
        """
            public async IAsyncEnumerable<Memory<byte>> {methodName}_Execute(CborReader reader)
            {
                var service = scope.ServiceProvider.GetRequiredService<I{serviceTypename}>();

                const int argumentSize = {argSize};

                var arraySize = reader.ReadStartArray();

                if (arraySize is null)
                    throw new InvalidOperationException();
                if (argumentSize != arraySize)
                    throw new InvalidOperationException();

                {fieldReadExpression}

                reader.ReadEndArray();

                await foreach (var e in service.{methodName}({fieldReadArgs}))
                {
                    var writer = new CborWriter();

                    IonFormatterStorage<{returnType}>.Write(writer, e);

                    var mem = MemoryPool<byte>.Shared.Rent(writer.BytesWritten);

                    writer.Encode(mem.Memory.Span);

                    yield return mem.Memory;

                    mem.Dispose();
                }
            }
        """;

    private static readonly string ServiceExecutorMethodNoReturnTemplate =
        """
            {compileGeneratedAttributes}
            public async Task {methodName}_Execute(CborReader reader, CborWriter writer)
            {
                var service = scope.ServiceProvider.GetRequiredService<I{serviceTypename}>();
            
                const int argumentSize = {argSize};
            
                var arraySize = reader.ReadStartArray();
            
                if (arraySize is null)
                    throw new InvalidOperationException();
                if (argumentSize != arraySize)
                    throw new InvalidOperationException();
                {fieldReadExpression}
            
                reader.ReadEndArray();
            
                await service.{methodName}({fieldReadArgs});
            }
        """;

    private static readonly string ServiceExecutorMethodWithReturnTemplate =
        """
            {compileGeneratedAttributes}
            public async Task {methodName}_Execute(CborReader reader, CborWriter writer)
            {
                var service = scope.ServiceProvider.GetRequiredService<I{serviceTypename}>();
            
                const int argumentSize = {argSize};
            
                var arraySize = reader.ReadStartArray();
            
                if (arraySize is null)
                    throw new InvalidOperationException();
                if (argumentSize != arraySize)
                    throw new InvalidOperationException();
                {fieldReadExpression}
            
                reader.ReadEndArray();
            
                var result = await service.{methodName}({fieldReadArgs});
                
                {writeResultExpression}
            }
        """;

    private static readonly string ServiceBranchExecute =
        """
                if (methodName.Equals("{methodName}", StringComparison.InvariantCultureIgnoreCase))
                    return {methodName}_Execute(reader, writer);
        """;

    private static readonly string ServiceStreamBranchExecute =
        """
                if (methodName.Equals("{methodName}", StringComparison.InvariantCultureIgnoreCase))
                    return {methodName}_Execute(reader);
        """;

    private string GenerateServiceExecutor(IonService service)
    {
        var interfaces = "";
        if (service.methods.Any(x => x.IsStreamable) && service.methods.Any(x => !x.IsStreamable))
            interfaces = "IServiceExecutorRouter, IServiceStreamExecutorRouter";
        else if (service.methods.All(x => x.IsStreamable))
            interfaces = "IServiceStreamExecutorRouter";
        else
            interfaces = "IServiceExecutorRouter";

        var methodsBuilder = new StringBuilder();
        var branchBuilder = new StringBuilder();
        var branchStreamBuilder = new StringBuilder();
        var serviceTypename = service.name.Identifier;
        var builder = ServiceExecutorTemplate
            .Replace("{serviceTypename}", serviceTypename)
            .Replace("{routerInterfaces}", interfaces)
            .Replace("{routerStreaming}", interfaces.Contains("IServiceStreamExecutorRouter") ? RouterStreamMethodTemplate : "")
            .Replace("{routerUnary}", interfaces.Contains("IServiceExecutorRouter") ? RouterMethodTemplate : "");

        branchBuilder.AppendLine();
        methodsBuilder.AppendLine();
        branchStreamBuilder.AppendLine();

        foreach (var method in service.methods)
        {
            if (method.IsStreamable)
                GenerateStreamMethodExecutor(method, serviceTypename, methodsBuilder, branchStreamBuilder);
            else
                GenerateUnaryMethodExecutor(method, serviceTypename, methodsBuilder, branchBuilder);
        }

        return builder
            .Replace("{body}", methodsBuilder.ToString())
            .Replace("{serviceRouteBranch}", branchBuilder.ToString())
            .Replace("{serviceStreamRouteBranch}", branchStreamBuilder.ToString());
    }

    private static void GenerateStreamMethodExecutor(IonMethod method, string serviceTypename,
        StringBuilder methodsBuilder,
        StringBuilder branchBuilder)
    {
        var methodName = method.name.Identifier;
        var argSize = method.arguments.Count;

        var readArgsExpression = GenerateReadArguments(method);
        var captureArgsExpression = GenerateCaptureField(method);

        var template = ServiceStreamExecutorMethodTemplate;

        var templateMethod =
            template
                .Replace("{serviceTypename}", serviceTypename)
                .Replace("{methodName}", methodName)
                .Replace("{argSize}", argSize.ToString())
                .Replace("{fieldReadExpression}", readArgsExpression)
                .Replace("{fieldReadArgs}", captureArgsExpression)
                .Replace("{returnType}", UnwrapType(method.returnType));

        methodsBuilder.AppendLine(templateMethod);


        var branch = ServiceStreamBranchExecute
            .Replace("{methodName}", methodName);

        branchBuilder.AppendLine(branch);
    }

    private static void GenerateUnaryMethodExecutor(IonMethod method, string serviceTypename, StringBuilder methodsBuilder,
        StringBuilder branchBuilder)
    {
        var methodName = method.name.Identifier;
        var argSize = method.arguments.Count;

        var readArgsExpression = GenerateReadArguments(method);
        var captureArgsExpression = GenerateCaptureField(method);

        var template = method.returnType.IsVoid
            ? ServiceExecutorMethodNoReturnTemplate
            : ServiceExecutorMethodWithReturnTemplate;

        var templateMethod =
            template
                .Replace("{serviceTypename}", serviceTypename)
                .Replace("{methodName}", methodName)
                .Replace("{argSize}", argSize.ToString())
                .Replace("{fieldReadExpression}", readArgsExpression)
                .Replace("{fieldReadArgs}", captureArgsExpression);

        if (!method.returnType.IsVoid)
            templateMethod = templateMethod
                .Replace("{writeResultExpression}", GenerateWriteReturnValue(method.returnType));

        methodsBuilder.AppendLine(templateMethod);


        var branch = ServiceBranchExecute
            .Replace("{methodName}", methodName);

        branchBuilder.AppendLine(branch);
    }


    private static readonly string ServiceClientImplTemplate =
        """
        {compileGeneratedAttributes}
        public sealed class Ion_{serviceTypename}_ClientImpl(IonClientContext context) : I{serviceTypename}
        {
            {MethodInfoDecls}

            {body}
        }
        """;

    private static readonly string ServiceClientMethodInfoDecl =
        """
            private static readonly Lazy<MethodInfo> {methodName}_Ref = new(() =>
                typeof(I{serviceTypename}).GetMethod(nameof({methodName}), BindingFlags.Public | BindingFlags.Instance)!);
        """;

    private static readonly string ServiceClientMethodDecl =
        """
            {compileGeneratedAttributes}
            public async Task<{methodReturnType}> {methodName}({args})
            {
                var req = new IonRequest(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);
            
                var writer = new CborWriter();
                
                const int argsSize = {argSize};
            
                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();
            
                return await req.CallAsync<{methodReturnType}>(writer.Encode());
            }
        """;

    private static readonly string ServiceClientMethodDeclNoReturn =
        """
            {compileGeneratedAttributes}
            public async Task {methodName}({args})
            {
                var req = new IonRequest(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);

                var writer = new CborWriter();
                
                const int argsSize = {argSize};

                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();

                await req.CallAsync(writer.Encode());
            }
        """;

    private static readonly string ServiceClientMethodDeclStream =
        """
            public IAsyncEnumerable<{methodReturnType}> {methodName}({args})
            {
                var ws = new IonWsClient(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);
            
                var writer = new CborWriter();
        
                const int argsSize = {argSize};
                
                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();
            
                return ws.CallServerStreamingAsync<{methodReturnType}>(writer.Encode());
            }
        """;

    private string GenerateServiceClientImpl(IonService service)
    {
        var methodsBuilder = new StringBuilder();
        var methodInfoDecl = new StringBuilder();
        var serviceTypename = service.name.Identifier;
        var builder = ServiceClientImplTemplate;

        methodInfoDecl.AppendLine();
        methodsBuilder.AppendLine();

        foreach (var method in service.methods)
        {
            var methodName = method.name.Identifier;
            var argSize = method.arguments.Count;

            var writeArgsExpression = GenerateWriteArguments(method);

            var methodArgs = string.Join(", ", method.arguments.Select(GenerateClientMethodArgument));

            var template =
                method.IsStreamable ? 
                    ServiceClientMethodDeclStream :
                        method.returnType.IsVoid
                        ? ServiceClientMethodDeclNoReturn
                        : ServiceClientMethodDecl;

            var templateMethod =
                template
                    .Replace("{serviceTypename}", serviceTypename)
                    .Replace("{methodName}", methodName)
                    .Replace("{argSize}", argSize.ToString())
                    .Replace("{argsWrite}", writeArgsExpression)
                    .Replace("{args}", methodArgs);

            if (!method.returnType.IsVoid)
                templateMethod = templateMethod
                    .Replace("{methodReturnType}", UnwrapType(method.returnType));

            methodsBuilder.AppendLine(templateMethod);


            var methodInfoDeclaration =
                ServiceClientMethodInfoDecl
                    .Replace("{methodName}", methodName)
                    .Replace("{serviceTypename}", serviceTypename);


            methodInfoDecl.AppendLine(methodInfoDeclaration);
        }

        return builder
            .Replace("{MethodInfoDecls}", methodInfoDecl.ToString())
            .Replace("{body}", methodsBuilder.ToString())
            .Replace("{serviceTypename}", serviceTypename);

        static string GenerateClientMethodArgument(IonArgument field) =>
            $"{UnwrapType(field.type)} __{field.name.Identifier.ToLowerInvariant()}";
    }

    private string GenerateUnion(IonUnion union)
    {
        var builder = new StringBuilder();

        var unionInterface =
            Union_InterfaceBody
                .Replace("{checkProps}", GenerateUnionCheckProps(union))
                .Replace("{unionName}", union.name.Identifier);


        builder.AppendLine();
        builder.AppendLine(unionInterface);


        var cases = GenerateUnionCase(union, out var targetTypesForFormatterGeneration);

        builder.AppendLine();
        builder.AppendLine(cases);

        builder.AppendLine();
        builder.AppendLine(GenerateUnionFormatterFraction(union));

        foreach (var ionType in targetTypesForFormatterGeneration)
        {
            //builder.AppendLine();
            //builder.AppendLine(GenerateMessage(ionType));
            builder.AppendLine();
            builder.AppendLine(GenerateFormatterForType(ionType));
        }

        return builder.ToString();
    }

    private string GenerateUnionCheckProps(IonUnion union)
    {
        var builder = new StringBuilder();

        foreach (var checkType in union.types)
        {
            builder.AppendLine();
            builder.AppendLine(Union_InterfaceBody_CheckProp
                .Replace("{caseTypeName}", checkType.name.Identifier));
        }

        return builder.ToString();
    }

    private string GenerateUnionCase(IonUnion union, out List<IonType> unionTypesRequiredFormatters)
    {
        unionTypesRequiredFormatters = new();
        var builder = new StringBuilder();
        var index = 0;
        foreach (var type in union.types)
        {
            if (!type.IsUnionCase)
            {
                index++;
                continue;
            }
            unionTypesRequiredFormatters.Add(type);

            var fields = string.Join(", ", type.fields.Select(f =>
                $"{GenerateField(f)}"));

            builder.AppendLine();
            builder.AppendLine(Union_CaseBody
                .Replace("{fields}", fields)
                .Replace("{caseTypeName}", type.name.Identifier)
                .Replace("{unionName}", union.name.Identifier)
                .Replace("{caseIndex}", index.ToString())
            );

            index++;
        }

        return builder.ToString();
    }

    private static readonly string Union_InterfaceBody =
        """
        {compileGeneratedAttributes}
        public interface I{unionName} : IIonUnion<I{unionName}>
        {
            string UnionKey { get; }
            uint UnionIndex { get; }
            
            {checkProps}
        }
        """;
    private static readonly string Union_InterfaceBody_CheckProp =
        """
            internal bool Is{caseTypeName} => this is {caseTypeName};
        """;

    private static readonly string Union_CaseBody =
        """
        {compileGeneratedAttributes}
        public sealed record {caseTypeName}({fields}) : I{unionName}
        {
            public string UnionKey => nameof({caseTypeName});
            public uint UnionIndex => {caseIndex};
        }
        """;

    private string GenerateUnionFormatterFraction(IonUnion union)
    {
        var builder = new StringBuilder();

        var writeChecks = new StringBuilder();
        var readChecks = new StringBuilder();
        var index = 0;
        foreach (var @case in union.types)
        {
            writeChecks.AppendLine();
            writeChecks.AppendLine(
                UnionWriteCheck
                    .Replace("{caseTypeName}", @case.name.Identifier)
                    .Replace("{caseIndex}", index.ToString())
            );


            readChecks.AppendLine();
            readChecks.AppendLine(
                UnionReadCheck
                    .Replace("{caseTypeName}", @case.name.Identifier)
                    .Replace("{caseIndex}", index.ToString())
            );

            index++;
        }


        builder.AppendLine();
        builder.AppendLine(Union_InterfaceFormatter
            .Replace("{unionInterface}", union.name.Identifier)
            .Replace("{readCheks}", readChecks.ToString())
            .Replace("{writeChecks}", writeChecks.ToString())
        );

        return builder.ToString();
    }


    private static readonly string Union_InterfaceFormatter =
        """
        {compileGeneratedAttributes}
        public sealed class Ion_I{unionInterface}_Formatter : IonFormatter<I{unionInterface}>
        {
            public I{unionInterface} Read(CborReader reader)
            {
                var unionIndex = reader.ReadUInt32();
        
                {readCheks}
        
                throw new InvalidOperationException();
            }
        
            public void Write(CborWriter writer, I{unionInterface} value)
            {
                writer.WriteUInt32(value.UnionIndex);
        
                {writeChecks}        
            }
        }
        """;

    private static readonly string UnionReadCheck =
        """
                if (unionIndex == {caseIndex})
                    return IonFormatterStorage<{caseTypeName}>.Read(reader);
        """;

    private static readonly string UnionWriteCheck =
        """
                if (value is {caseTypeName} n_{caseIndex})
                {
                    if (n_{caseIndex}.UnionIndex != {caseIndex})
                        throw new InvalidOperationException();
                    IonFormatterStorage<{caseTypeName}>.Write(writer, n_{caseIndex});
                    return;
                }
        """;
}
