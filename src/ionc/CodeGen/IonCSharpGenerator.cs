namespace ion.compiler.CodeGen;

using ion.runtime;
using Microsoft.Build.Construction;
using Pidgin;
using syntax;
using System.Formats.Cbor;
using System.Linq;
using System.Text;
using static ion.compiler.CodeGen.IonCSharpGenerator;

public class IonProject
{
    public required string Name { get; set; }

    public IonProjectCSharpSettings? Dotnet { get; set; }


    public class IonProjectCSharpSettings
    {
        public string TargetFramework { get; set; } = "net9.0";

        public string IonRuntimeVersion { get; set; } = "0.0.1";

        public required DirectoryInfo OutputPath { get; set; }
    }
}

public static class FileEx
{
    public static FileInfo File(this DirectoryInfo directory, string file) =>
        new(Path.Combine(directory.FullName, file));
}

public class IonCSharpGenerator(string @namespace)
{

    private string FileHeader()
    {
        return $"""
               //------------------------------------------------------------------------------
               // <auto-generated>
               //     This code was generated by a code generation tool.
               //     Changes to this file may cause incorrect behavior and will be lost
               //     if the code is regenerated.
               //
               //     Generator: IonPath Codegen
               // </auto-generated>
               //------------------------------------------------------------------------------

               #pragma warning disable
               #nullable enable
               
               
               namespace {@namespace};
               """;
    }

    public static void GenerateCsproj(string projectName, FileInfo outputFile)
    {
        var project = ProjectRootElement.Create();
        project.Sdk = "Microsoft.NET.Sdk";

        var propertyGroup = project.AddPropertyGroup();
        propertyGroup.AddProperty("OutputType", "Library");
        propertyGroup.AddProperty("TargetFramework", "net9.0");
        propertyGroup.AddProperty("ImplicitUsings", "enable");
        propertyGroup.AddProperty("RootNamespace", projectName);

        var itemGroup = project.AddItemGroup();
        itemGroup.AddItem("PackageReference", "ion.runtime")
            .AddMetadata("Version", "1.0.0", expressAsAttribute: true);

        project.Save(outputFile.FullName);
    }


    public static string GenerateGlobalTypes() =>
        """
        global using i1 = System.SByte;
        global using i2 = System.Int16;
        global using i4 = System.Int32;
        global using i8 = System.Int64;
        global using i16 = System.Int128;

        global using u1 = System.Byte;
        global using u2 = System.UInt16;
        global using u4 = System.UInt32;
        global using u8 = System.UInt64;
        global using u16 = System.UInt128;

        global using f2 = System.Half;
        global using f4 = System.Single;
        global using f8 = System.Double;
        global using guid = System.Guid;
        global using dateonly = System.DateOnly;
        global using timeonly = System.TimeOnly;
        global using duration = System.TimeSpan;
        global using datetime = System.DateTime;
        
        global using System.CodeDom.Compiler;
        global using System.Runtime.CompilerServices;
        
        global using System.Formats.Cbor;
        global using ion.runtime;
        """;

    public string GenerateModule(IonModule module)
    {
        var sb = new StringBuilder();
        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var type in module.Definitions)
        {
            sb.AppendLine(GenerateType(type));
            sb.AppendLine();
        }

        foreach (var service in module.Services)
        {
            sb.AppendLine(GenerateService(service));
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static string GenerateType(IonType type)
    {
        if (type is IonEnum enumType)
            return GenerateEnum(enumType);
        if (type is IonFlags flagsType)
            return GenerateFlags(flagsType);
        if (type is IonGenericType)
            return null;
        if (type.isTypedef)
            return GenerateTypedef(type);
        return GenerateMessage(type);
    }

    private static string GenerateEnum(IonEnum e)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
                      [GeneratedCode("IonPath Codegen", "0.0.0")]
                      [CompilerGenerated]
                      """);
        sb.AppendLine($"public enum {e.name.Identifier}");
        sb.AppendLine("{");
        foreach (var m in e.members)
            sb.AppendLine($"    {m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateFlags(IonFlags f)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
                      [GeneratedCode("IonPath Codegen", "0.0.0")]
                      [CompilerGenerated]
                      """);
        sb.AppendLine("[Flags]");
        sb.AppendLine($"public enum {f.name.Identifier}");
        sb.AppendLine("{");
        foreach (var m in f.members)
            sb.AppendLine($"    {m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateTypedef(IonType type)
    {
        var underlying = ResolveTypeName(type.fields.FirstOrDefault()?.type);
        return $"public readonly record struct {type.name.Identifier}({underlying} Value);";
    }

    private static string GenerateMessage(IonType type)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
                      [GeneratedCode("IonPath Codegen", "0.0.0")]
                      [CompilerGenerated]
                      """);
        sb.Append($"public sealed record {type.name.Identifier}(");
        sb.Append(string.Join(", ", type.fields.Select(f =>
            $"{GenerateField(f)}")));
        sb.AppendLine(");");
        return sb.ToString();
    }

    private static string GenerateService(IonService service)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
                      [GeneratedCode("IonPath Codegen", "0.0.0")]
                      [CompilerGenerated]
                      """);
        sb.AppendLine($"public interface I{service.name.Identifier}");
        sb.AppendLine("{");

        foreach (var method in service.methods)
        {
            var args = string.Join(", ", method.arguments.Select(GenerateArgument));
            sb.AppendLine($"    {GenerateReturnType(method)} {method.name.Identifier}({args});");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateField(IonField field) => $"{UnwrapType(field.type)} {field.name.Identifier}";

    private static string GenerateArgument(IonArgument field) => $"{UnwrapType(field.type)} {field.name.Identifier}";

    private static string UnwrapType(IonType type) => type switch
    {
        IonGenericType { IsMaybe: true } maybe => $"IonMaybe<{ResolveTypeName(maybe.TypeArguments[0])}>",
        IonGenericType { IsArray: true } array => $"IonArray<{ResolveTypeName(array.TypeArguments[0])}>",
        IonGenericType generic => GenerateGenericTypeName(generic),
        _ => ResolveTypeName(type)
    };

    private static string GenerateGenericTypeName(IonGenericType generic) 
        => $"{generic.name.Identifier}<{string.Join(',', generic.TypeArguments.Select(x => x.name.Identifier))}>";

    private static string ResolveTypeName(IonType type) => type.name.Identifier;

    private static string GenerateReturnType(IonMethod method)
    {
        if (method.returnType.IsVoid)
            return "Task";
        if (method.IsStreamable)
            return $"Task<IAsyncEnumerable<{UnwrapType(method.returnType)}>>";
        return $"Task<{UnwrapType(method.returnType)}>";
    }

    public string FormatterTemplate =>
        """
        [GeneratedCode("IonPath Codegen", "0.0.0")]
        [CompilerGenerated]
        public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
        {
            public {ionType} Read(CborReader reader)
            {
                {fieldReadExpression}
                return new({ctorFields});
            }

            public void Write(CborWriter writer, {ionType} value)
            {
                {fieldWriteExpression}
            }
        }
        """;

    public static string FormatterTemplateRef(IonType type)
    {
        if (type.IsVoid)
            throw new InvalidOperationException();
        return $"IonFormatterStorage<{UnwrapType(type)}>";
    }

    public string GenerateAllFormatters(IEnumerable<IonType> types)
    {
        var candidates = types.Where(t => t is { IsBuiltin: false, IsScalar: false, IsVoid: false }).ToArray();
        var sorted = TopoSortByDependencies(candidates);

        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());

        foreach (var t in sorted)
        {
            sb.AppendLine(GenerateFormatterForType(t));
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static string GenerateFormatterForEnum(IonEnum @enum) =>
        """
            [GeneratedCode("IonPath Codegen", "0.0.0")]
            [CompilerGenerated]
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }

                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");
    private static string GenerateFormatterForFlags(IonFlags @enum) =>
        """
            [GeneratedCode("IonPath Codegen", "0.0.0")]
            [CompilerGenerated]
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }

                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");


    private string GenerateFormatterForType(IonType type)
    {
        if (type is IonEnum @enum)
            return GenerateFormatterForEnum(@enum);
        if (type is IonFlags flags)
            return GenerateFormatterForFlags(flags);

        var name = type.name.Identifier;

        var template = FormatterTemplate
            .Replace("{ionType}", name)
            .Replace("{fieldReadExpression}", GenerateReadField(type))
            .Replace("{ctorFields}", GenerateCaptureField(type))
            .Replace("{fieldWriteExpression}", GenerateWriteField(type));

        return template;
    }

    private static string GenerateCaptureField(IonType type) 
        => string.Join(", ", type.fields.Select(x => $"__{x.name.Identifier.ToLowerInvariant()}"));

    private static string GenerateReadField(IonType type) =>
        string.Join($"\n{new string(' ', 8)}", type.fields.Select(GenerateReadField));

    private static string GenerateReadField(IonField field) =>
        field switch
        {
            { type: { IsArray: true } } => GenerateReadArrayField(field),
            { type: { IsMaybe: true } } => GenerateReadMaybeField(field),
            _ => $"var __{field.name.Identifier.ToLowerInvariant()} = {FormatterTemplateRef(field.type)}.Read(reader);"
        };

    private static string GenerateReadArrayField(IonField field)
    {
        if (field.type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"var __{field.name.Identifier.ToLowerInvariant()} = IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.ReadArray(reader);";
    }

    private static string GenerateReadMaybeField(IonField field)
    {
        if (field.type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"var __{field.name.Identifier.ToLowerInvariant()} = IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.ReadMaybe(reader);";
    }

    private static string GenerateWriteField(IonType type)
        => string.Join($"\n{new string(' ', 8)}", type.fields.Select(GenerateWriteField));
    private static string GenerateWriteField(IonField field)
    {
        return field switch
        {
            { type: { IsArray: true } } => GenerateWriteArrayField(field),
            { type: { IsMaybe: true } } => GenerateWriteMaybeField(field),
            _ => $"{FormatterTemplateRef(field.type)}.Write(writer, value.{field.name.Identifier});"
        };
    }

    private static string GenerateWriteArrayField(IonField field)
    {
        if (field.type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteArray(writer, value.{field.name.Identifier});";
    }

    private static string GenerateWriteMaybeField(IonField field)
    {
        if (field.type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteMaybe(writer, value.{field.name.Identifier});";
    }

    private static IReadOnlyList<IonType> TopoSortByDependencies(IReadOnlyList<IonType> types)
    {
        var byName = types.ToDictionary(t => t.name.Identifier, t => t);
        var visited = new HashSet<string>();
        var temp = new HashSet<string>();
        var result = new List<IonType>();

        foreach (var t in types) Visit(t);
        return result;

        void Visit(IonType t)
        {
            var key = t.name.Identifier;
            if (visited.Contains(key)) return;
            if (!temp.Add(key)) return;

            foreach (var f in t.fields ?? [])
            {
                var ft = f.type;
                if (ft is null || ft.IsBuiltin || ft.IsScalar || ft.IsVoid) continue;
                if (byName.TryGetValue(ft.name.Identifier, out var dep))
                    Visit(dep);
            }

            temp.Remove(key);
            visited.Add(key);
            result.Add(t);
        }
    }
}