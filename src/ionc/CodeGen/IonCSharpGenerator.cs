namespace ion.compiler.CodeGen;

using ion.runtime;
using Microsoft.Build.Construction;
using Pidgin;
using syntax;
using System.Formats.Cbor;
using System.Linq;
using System.Text;
using Microsoft.Build.Evaluation;
using static ion.compiler.CodeGen.IonCSharpGenerator;

public class IonProject
{
    public required string Name { get; set; }

    public IonProjectCSharpSettings? Dotnet { get; set; }


    public class IonProjectCSharpSettings
    {
        public string TargetFramework { get; set; } = "net9.0";

        public string IonRuntimeVersion { get; set; } = "0.0.1";

        public required DirectoryInfo OutputPath { get; set; }
    }
}

public static class FileEx
{
    public static FileInfo File(this DirectoryInfo directory, string file) =>
        new(Path.Combine(directory.FullName, file));

    public static DirectoryInfo Combine(this DirectoryInfo directory, string atFolder)
    {
        if (atFolder.StartsWith("@"))
            return new DirectoryInfo(Path.Combine(directory.FullName, atFolder.Replace("@", ".")));
        return new DirectoryInfo(atFolder);
    }
}

public class IonCSharpGenerator(string @namespace)
{

    private string FileHeader()
    {
        return $"""
               //------------------------------------------------------------------------------
               // <auto-generated>
               //     This code was generated by a code generation tool.
               //     Changes to this file may cause incorrect behavior and will be lost
               //     if the code is regenerated.
               //
               //     Generator: IonPath Codegen
               // </auto-generated>
               //------------------------------------------------------------------------------

               #pragma warning disable
               #nullable enable
               
               
               namespace {@namespace};
               """;
    }

    private static readonly string ModuleInitTemplate =
        """
        public static class IonProjectFormatterStorageModuleInit
        {
            [ModuleInitializer]
            public static void Init()
            {
                {formatters}
            }
        }
        """;

    public string GenerateModuleInit(IEnumerable<IonType> types, IEnumerable<IonService> services)
    {
        var candidates = types.Where(t => t is { IsBuiltin: false, IsScalar: false, IsVoid: false }).ToArray();
        var sorted = TopoSortByDependencies(candidates);

        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());

        var formattersSb = new StringBuilder();

        formattersSb.AppendLine();

        foreach (var t in sorted)
        {
            var typeName = t.name.Identifier;
            formattersSb.AppendLine($"      IonFormatterStorage<{typeName}>.Value = new Ion_{typeName}_Formatter();");
        }

        foreach (var service in services)
        {
            var typeName = service.name.Identifier;
            formattersSb.AppendLine(
                $"      IonExecutorMetadataStorage.Add<Ion_{typeName}_ServiceExecutor>(\"I{typeName}\");");
        }

        sb.AppendLine(ModuleInitTemplate.Replace("{formatters}", formattersSb.ToString()));

        return sb.ToString();
    }

    public static void GenerateCsproj(string projectName, FileInfo outputFile)
    {
        var project = ProjectRootElement.Create(NewProjectFileOptions.None);
        project.Sdk = "Microsoft.NET.Sdk";

        var propertyGroup = project.AddPropertyGroup();
        propertyGroup.AddProperty("OutputType", "Library");
        propertyGroup.AddProperty("TargetFramework", "net9.0");
        propertyGroup.AddProperty("ImplicitUsings", "enable");
        propertyGroup.AddProperty("RootNamespace", projectName);

        var itemGroup = project.AddItemGroup();
        itemGroup.AddItem("PackageReference", "ion.runtime")
            .AddMetadata("Version", "1.0.0-beta.1", expressAsAttribute: true);
        itemGroup.AddItem("PackageReference", "ion.runtime.network")
            .AddMetadata("Version", "1.0.0-beta.1", expressAsAttribute: true);

        project.Save(outputFile.FullName);
    }


    public static string GenerateGlobalTypes() =>
        """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a code generation tool.
        //     Changes to this file may cause incorrect behavior and will be lost
        //     if the code is regenerated.
        //
        //     Generator: IonPath Codegen
        // </auto-generated>
        //------------------------------------------------------------------------------
        
        #pragma warning disable
        
        global using i1 = System.SByte;
        global using i2 = System.Int16;
        global using i4 = System.Int32;
        global using i8 = System.Int64;
        global using i16 = System.Int128;

        global using u1 = System.Byte;
        global using u2 = System.UInt16;
        global using u4 = System.UInt32;
        global using u8 = System.UInt64;
        global using u16 = System.UInt128;

        global using f2 = System.Half;
        global using f4 = System.Single;
        global using f8 = System.Double;
        global using guid = System.Guid;
        global using dateonly = System.DateOnly;
        global using timeonly = System.TimeOnly;
        global using duration = System.TimeSpan;
        global using datetime = System.DateTime;
        
        global using System.CodeDom.Compiler;
        global using System.Runtime.CompilerServices;
        
        global using System.Formats.Cbor;
        global using ion.runtime;
        global using ion.runtime.network;
        global using Microsoft.Extensions.DependencyInjection;
        """;

    public string GenerateModule(IonModule module)
    {
        var sb = new StringBuilder();
        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var type in module.Definitions)
        {
            sb.AppendLine(GenerateType(type));
            sb.AppendLine();
        }

        foreach (var service in module.Services)
        {
            sb.AppendLine(GenerateService(service));
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static string GenerateType(IonType type)
    {
        if (type is IonEnum enumType)
            return GenerateEnum(enumType);
        if (type is IonFlags flagsType)
            return GenerateFlags(flagsType);
        if (type is IonGenericType)
            return null;
        if (type.isTypedef)
            return GenerateTypedef(type);
        return GenerateMessage(type);
    }

    private static string GenerateEnum(IonEnum e)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
                      [GeneratedCode("IonPath Codegen", "0.0.0")]
                      [CompilerGenerated]
                      """);
        sb.AppendLine($"public enum {e.name.Identifier}");
        sb.AppendLine("{");
        foreach (var m in e.members)
            sb.AppendLine($"    {m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateFlags(IonFlags f)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
                      [GeneratedCode("IonPath Codegen", "0.0.0")]
                      [CompilerGenerated]
                      """);
        sb.AppendLine("[Flags]");
        sb.AppendLine($"public enum {f.name.Identifier}");
        sb.AppendLine("{");
        foreach (var m in f.members)
            sb.AppendLine($"    {m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateTypedef(IonType type)
    {
        var underlying = ResolveTypeName(type.fields.FirstOrDefault()?.type);
        return $"public readonly record struct {type.name.Identifier}({underlying} Value);";
    }

    private static string GenerateMessage(IonType type)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
                      [GeneratedCode("IonPath Codegen", "0.0.0")]
                      [CompilerGenerated]
                      """);
        sb.Append($"public sealed record {type.name.Identifier}(");
        sb.Append(string.Join(", ", type.fields.Select(f =>
            $"{GenerateField(f)}")));
        sb.AppendLine(");");
        return sb.ToString();
    }

    private static string GenerateService(IonService service)
    {
        var sb = new StringBuilder();
        sb.AppendLine("""
                      [GeneratedCode("IonPath Codegen", "0.0.0")]
                      [CompilerGenerated]
                      """);
        sb.AppendLine($"public interface I{service.name.Identifier}");
        sb.AppendLine("{");

        foreach (var method in service.methods)
        {
            var args = string.Join(", ", method.arguments.Select(GenerateArgument));
            sb.AppendLine($"    {GenerateReturnType(method)} {method.name.Identifier}({args});");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateField(IonField field) => $"{UnwrapType(field.type)} {field.name.Identifier}";

    private static string GenerateArgument(IonArgument field) => $"{UnwrapType(field.type)} {field.name.Identifier}";

    private static string UnwrapType(IonType type) => type switch
    {
        IonGenericType { IsMaybe: true } maybe => $"IonMaybe<{ResolveTypeName(maybe.TypeArguments[0])}>",
        IonGenericType { IsArray: true } array => $"IonArray<{ResolveTypeName(array.TypeArguments[0])}>",
        IonGenericType generic => GenerateGenericTypeName(generic),
        _ => ResolveTypeName(type)
    };

    private static string GenerateGenericTypeName(IonGenericType generic) 
        => $"{generic.name.Identifier}<{string.Join(',', generic.TypeArguments.Select(x => x.name.Identifier))}>";

    private static string ResolveTypeName(IonType type) => type.name.Identifier;

    private static string GenerateReturnType(IonMethod method)
    {
        if (method.returnType.IsVoid)
            return "Task";
        if (method.IsStreamable)
            return $"Task<IAsyncEnumerable<{UnwrapType(method.returnType)}>>";
        return $"Task<{UnwrapType(method.returnType)}>";
    }

    public string FormatterTemplate =>
        """
        [GeneratedCode("IonPath Codegen", "0.0.0")]
        [CompilerGenerated]
        public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
        {
            public {ionType} Read(CborReader reader)
            {
                {fieldReadExpression}
                return new({ctorFields});
            }

            public void Write(CborWriter writer, {ionType} value)
            {
                {fieldWriteExpression}
            }
        }
        """;

    public static string FormatterTemplateRef(IonType type)
    {
        if (type.IsVoid)
            throw new InvalidOperationException();
        return $"IonFormatterStorage<{UnwrapType(type)}>";
    }

    public string GenerateAllServiceExecutors(IEnumerable<IonService> service)
    {
        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var ionService in service)
        {
            sb.AppendLine(GenerateServiceExecutor(ionService));
            sb.AppendLine();
        }
        return sb.ToString();
    }

    public string GenerateAllFormatters(IEnumerable<IonType> types)
    {
        var candidates = types.Where(t => t is { IsBuiltin: false, IsScalar: false, IsVoid: false }).ToArray();
        var sorted = TopoSortByDependencies(candidates);

        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());

        foreach (var t in sorted)
        {
            sb.AppendLine(GenerateFormatterForType(t));
            sb.AppendLine();
        }

        return sb.ToString();
    }

    private static string GenerateFormatterForEnum(IonEnum @enum) =>
        """
            [GeneratedCode("IonPath Codegen", "0.0.0")]
            [CompilerGenerated]
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }

                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");
    private static string GenerateFormatterForFlags(IonFlags @enum) =>
        """
            [GeneratedCode("IonPath Codegen", "0.0.0")]
            [CompilerGenerated]
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }

                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");


    private string GenerateFormatterForType(IonType type)
    {
        if (type is IonEnum @enum)
            return GenerateFormatterForEnum(@enum);
        if (type is IonFlags flags)
            return GenerateFormatterForFlags(flags);

        var name = type.name.Identifier;

        var template = FormatterTemplate
            .Replace("{ionType}", name)
            .Replace("{fieldReadExpression}", GenerateReadField(type))
            .Replace("{ctorFields}", GenerateCaptureField(type))
            .Replace("{fieldWriteExpression}", GenerateWriteField(type));

        return template;
    }

    private static string GenerateCaptureField(IonType type) 
        => string.Join(", ", type.fields.Select(x => $"__{x.name.Identifier.ToLowerInvariant()}"));
    private static string GenerateCaptureField(IonMethod method)
        => string.Join(", ", method.arguments.Select(x => $"__{x.name.Identifier.ToLowerInvariant()}"));

    private static string GenerateReadField(IonType type) =>
        string.Join($"\n{new string(' ', 8)}", type.fields.Select(GenerateReadField));

    private static string GenerateReadField(IonField field) =>
        field switch
        {
            { type: { IsArray: true } } => GenerateReadArrayField(field),
            { type: { IsMaybe: true } } => GenerateReadMaybeField(field),
            _ => $"var __{field.name.Identifier.ToLowerInvariant()} = {FormatterTemplateRef(field.type)}.Read(reader);"
        };

    private static string GenerateReadArgument(IonArgument argument) =>
        argument switch
        {
            { type: { IsArray: true } } => GenerateReadArrayField(argument),
            { type: { IsMaybe: true } } => GenerateReadMaybeField(argument),
            _ => $"var __{argument.name.Identifier.ToLowerInvariant()} = {FormatterTemplateRef(argument.type)}.Read(reader);"
        };

    private static string GenerateReadArrayField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"var __{field.Name.Identifier.ToLowerInvariant()} = IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.ReadArray(reader);";
    }

    private static string GenerateReadMaybeField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"var __{field.Name.Identifier.ToLowerInvariant()} = IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.ReadMaybe(reader);";
    }

    private static string GenerateWriteReturnValue(IonType returnType) =>
        returnType switch
        {
            { IsArray: true } => GenerateWriteReturnValueForArray(returnType),
            { IsMaybe: true } => GenerateWriteReturnValueForMaybe(returnType),
            _ => $"{FormatterTemplateRef(returnType)}.Write(writer, result);"
        };

    private static string GenerateWriteReturnValueForArray(IonType returnType)
    {
        if (returnType is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return $"{FormatterTemplateRef(arrayType.TypeArguments.First())}.WriteArray(writer, result);";
    }

    private static string GenerateWriteReturnValueForMaybe(IonType returnType)
    {
        if (returnType is not IonGenericType { IsMaybe: true } maybeType)
            throw new InvalidOperationException();
        return $"{FormatterTemplateRef(maybeType.TypeArguments.First())}.WriteMaybe(writer, result);";
    }

    private static string GenerateWriteField(IonType type)
        => string.Join($"\n{new string(' ', 8)}", type.fields.Select(GenerateWriteField));
    private static string GenerateWriteField(IonField field)
    {
        return field switch
        {
            { type: { IsArray: true } } => GenerateWriteArrayField(field),
            { type: { IsMaybe: true } } => GenerateWriteMaybeField(field),
            _ => $"{FormatterTemplateRef(field.type)}.Write(writer, value.{field.name.Identifier});"
        };
    }

    private static string GenerateReadArguments(IonMethod method)
        => string.Join($"\n{new string(' ', 8)}", method.arguments.Select(GenerateReadArgument));

    private static string GenerateWriteArrayField(IonField field)
    {
        if (field.type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteArray(writer, value.{field.name.Identifier});";
    }

    private static string GenerateWriteMaybeField(IonField field)
    {
        if (field.type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteMaybe(writer, value.{field.name.Identifier});";
    }

    private static IReadOnlyList<IonType> TopoSortByDependencies(IReadOnlyList<IonType> types)
    {
        var byName = types.ToDictionary(t => t.name.Identifier, t => t);
        var visited = new HashSet<string>();
        var temp = new HashSet<string>();
        var result = new List<IonType>();

        foreach (var t in types) Visit(t);
        return result;

        void Visit(IonType t)
        {
            var key = t.name.Identifier;
            if (visited.Contains(key)) return;
            if (!temp.Add(key)) return;

            foreach (var f in t.fields ?? [])
            {
                var ft = f.type;
                if (ft is null || ft.IsBuiltin || ft.IsScalar || ft.IsVoid) continue;
                if (byName.TryGetValue(ft.name.Identifier, out var dep))
                    Visit(dep);
            }

            temp.Remove(key);
            visited.Add(key);
            result.Add(t);
        }
    }


    private static readonly string ServiceExecutorTemplate =
        """
        [GeneratedCode("IonPath Codegen", "0.0.0")]
        [CompilerGenerated]
        public sealed class Ion_{serviceTypename}_ServiceExecutor(AsyncServiceScope scope) : IServiceExecutorRouter
        {
            {body}
            
            
            [GeneratedCode("IonPath Codegen", "0.0.0")]
            [CompilerGenerated]
            public Task RouteExecuteAsync(string methodName, CborReader reader, CborWriter writer)
            {
                {serviceRouteBranch}
                
                throw new InvalidOperationException("no method defined");
            }
        }
        """;

    private static readonly string ServiceExecutorMethodNoReturnTemplate =
        """
            [GeneratedCode("IonPath Codegen", "0.0.0")]
            [CompilerGenerated]
            public async Task {methodName}_Execute(CborReader reader, CborWriter writer)
            {
                var service = scope.ServiceProvider.GetRequiredService<I{serviceTypename}>();
            
                const int argumentSize = {argSize};
            
                var arraySize = reader.ReadStartArray();
            
                if (arraySize is null)
                    throw new InvalidOperationException();
                if (argumentSize != arraySize)
                    throw new InvalidOperationException();
                {fieldReadExpression}
            
                reader.ReadEndArray();
            
                await service.{methodName}({fieldReadArgs});
            }
        """;

    private static readonly string ServiceExecutorMethodWithReturnTemplate =
        """
            [GeneratedCode("IonPath Codegen", "0.0.0")]
            [CompilerGenerated]
            public async Task {methodName}_Execute(CborReader reader, CborWriter writer)
            {
                var service = scope.ServiceProvider.GetRequiredService<I{serviceTypename}>();
            
                const int argumentSize = {argSize};
            
                var arraySize = reader.ReadStartArray();
            
                if (arraySize is null)
                    throw new InvalidOperationException();
                if (argumentSize != arraySize)
                    throw new InvalidOperationException();
                {fieldReadExpression}
            
                reader.ReadEndArray();
            
                var result = await service.{methodName}({fieldReadArgs});
                
                {writeResultExpression}
            }
        """;

    private static readonly string ServiceBranchExecute =
        """
                if (methodName.Equals("{methodName}", StringComparison.InvariantCultureIgnoreCase))
                    return {methodName}_Execute(reader, writer);
        """;

    private string GenerateServiceExecutor(IonService service)
    {
        var methodsBuilder = new StringBuilder();
        var branchBuilder = new StringBuilder();
        var serviceTypename = service.name.Identifier;
        var builder = ServiceExecutorTemplate
            .Replace("{serviceTypename}", serviceTypename);

        branchBuilder.AppendLine();
        methodsBuilder.AppendLine();

        foreach (var method in service.methods)
        {
            if (method.IsStreamable)
                continue;

            var methodName = method.name.Identifier;
            var argSize = method.arguments.Count;

            var readArgsExpression = GenerateReadArguments(method);
            var captureArgsExpression = GenerateCaptureField(method);

            var template = method.returnType.IsVoid
                ? ServiceExecutorMethodNoReturnTemplate
                : ServiceExecutorMethodWithReturnTemplate;

            var templateMethod =
                template
                    .Replace("{serviceTypename}", serviceTypename)
                    .Replace("{methodName}", methodName)
                    .Replace("{argSize}", argSize.ToString())
                    .Replace("{fieldReadExpression}", readArgsExpression)
                    .Replace("{fieldReadArgs}", captureArgsExpression);

            if (!method.returnType.IsVoid)
                templateMethod = templateMethod
                    .Replace("{writeResultExpression}", GenerateWriteReturnValue(method.returnType));

            methodsBuilder.AppendLine(templateMethod);


            var branch = ServiceBranchExecute
                .Replace("{methodName}", methodName);

            branchBuilder.AppendLine(branch);
        }

        return builder
            .Replace("{body}", methodsBuilder.ToString())
            .Replace("{serviceRouteBranch}", branchBuilder.ToString());
    }
}