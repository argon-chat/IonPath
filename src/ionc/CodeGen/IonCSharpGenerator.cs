namespace ion.compiler.CodeGen;

using ion.runtime;
using Pidgin;
using syntax;
using System.Formats.Cbor;
using System.Linq;
using System.Reflection.PortableExecutable;
using System.Text;
using static ion.compiler.CodeGen.IonCSharpGenerator;

public class IonProject
{
    public required string Name { get; set; }

    public IonProjectCSharpSettings? Dotnet { get; set; }


    public class IonProjectCSharpSettings
    {
        public string TargetFramework { get; set; } = "net10.0";

        public string IonRuntimeVersion { get; set; } = "0.0.1";

        public required DirectoryInfo OutputPath { get; set; }
    }
}

public static class IonCSharpGeneratorEx
{
    private static readonly string CompileGenerateAttributes = // {compileGeneratedAttributes}
        "[GeneratedCodeAttribute(\"ionc\", null), CompilerGeneratedAttribute]";

    public static string ToCompiledString(this StringBuilder builder)
        => builder.ToString().Replace("{compileGeneratedAttributes}", CompileGenerateAttributes);
}

public class IonCSharpGenerator(string @namespace) : IIonCodeGenerator
{
    public static bool UseMaybeWrapper { get; set; }

    // Make FileHeader public to satisfy interface
    public string FileHeader()
    {
        return $"""
                //------------------------------------------------------------------------------
                // <auto-generated>
                //     This code was generated by a code generation tool.
                //     Changes to this file may cause incorrect behavior and will be lost
                //     if the code is regenerated.
                //
                //     Generator: IonPath Codegen
                // </auto-generated>
                //------------------------------------------------------------------------------

                #pragma warning disable
                #nullable enable


                namespace {@namespace};
                """;
    }

    public void GenerateProjectFile(string projectName, FileInfo outputFile)
    {
    }

    // Add GenerateTypes to satisfy interface
    public string GenerateTypes(IEnumerable<IonType> types)
    {
        var sb = new StringBuilder();
        var allTypes = types.ToList();

        foreach (var type in allTypes.Where(type => type is { IsUnionCase: false, IsUnion: false }))
        {
            var generated = GenerateType(type);
            if (!string.IsNullOrEmpty(generated))
            {
                sb.AppendLine(generated);
                sb.AppendLine();
            }
        }

        foreach (var union in allTypes.OfType<IonUnion>())
        {
            sb.AppendLine(GenerateUnion(union));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }

    // Add GenerateServices to satisfy interface
    public string GenerateServices(IonModule module)
    {
        var sb = new StringBuilder();
        foreach (var service in module.Services)
        {
            sb.AppendLine(GenerateService(service));
            sb.AppendLine();
        }
        return sb.ToCompiledString();
    }

    private static readonly string ModuleInitTemplate =
        """
        {compileGeneratedAttributes}
        internal static class IonProjectFormatterStorageModuleInit
        {
            [ModuleInitializer]
            internal static void Init()
            {
                {formatters}
            }
        }
        """;

    public string GenerateModuleInit(IEnumerable<IonType> types, IReadOnlyList<IonService> services, bool clientToo,
        bool serverToo)
    {
        var candidates = types.Where(t => t is { IsBuiltin: false, IsScalar: false, IsVoid: false }).ToArray();

        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());

        var formattersSb = new StringBuilder();

        formattersSb.AppendLine();

        foreach (var t in candidates)
            formattersSb.AppendLine(
                $"      IonFormatterStorage<{UnwrapType(t)}>.Value = new Ion_{UnwrapType(t)}_Formatter();");

        foreach (var t in candidates.Where(x => x.IsUnion).OfType<IonUnion>().SelectMany(x => x.types)
                     .Where(x => x.IsUnionCase))
            formattersSb.AppendLine(
                $"      IonFormatterStorage<{UnwrapType(t)}>.Value = new Ion_{UnwrapType(t)}_Formatter();");

        if (serverToo)
        {
            foreach (var service in services)
            {
                var typeName = service.name.Identifier;
                formattersSb.AppendLine(
                    $"      IonExecutorMetadataStorage.AddExecutor<Ion_{typeName}_ServiceExecutor>(\"I{typeName}\");");
            }
        }

        if (clientToo)
        {
            foreach (var service in services)
            {
                var typeName = service.name.Identifier;
                formattersSb.AppendLine(
                    $"      IonExecutorMetadataStorage.AddClient<Ion_{typeName}_ClientImpl>(\"I{typeName}\");");
            }
        }


        sb.AppendLine(ModuleInitTemplate.Replace("{formatters}", formattersSb.ToString()));

        return sb.ToCompiledString();
    }

    public string GenerateGlobalTypes() =>
        """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a code generation tool.
        //     Changes to this file may cause incorrect behavior and will be lost
        //     if the code is regenerated.
        //
        //     Generator: IonPath Codegen
        // </auto-generated>
        //------------------------------------------------------------------------------

        #pragma warning disable

        global using i1 = System.SByte;
        global using i2 = System.Int16;
        global using i4 = System.Int32;
        global using i8 = System.Int64;
        global using i16 = System.Int128;

        global using u1 = System.Byte;
        global using u2 = System.UInt16;
        global using u4 = System.UInt32;
        global using u8 = System.UInt64;
        global using u16 = System.UInt128;

        global using f2 = System.Half;
        global using f4 = System.Single;
        global using f8 = System.Double;
        global using guid = System.Guid;
        global using dateonly = System.DateOnly;
        global using timeonly = System.TimeOnly;
        global using duration = System.TimeSpan;
        global using datetime = System.DateTime;

        global using System.CodeDom.Compiler;
        global using System.Runtime.CompilerServices;

        global using System.Formats.Cbor;
        global using ion.runtime;
        global using ion.runtime.network;
        global using Microsoft.Extensions.DependencyInjection;
        global using System.Diagnostics;
        global using System.Reflection;
        global using ion.runtime.client;
        global using System.Buffers;
        """;

    public string GenerateModule(IonModule module)
    {
        var sb = new StringBuilder();
        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var type in module.Definitions.Where(type => type is { IsUnionCase: false, IsUnion: false }))
        {
            sb.AppendLine(GenerateType(type));
            sb.AppendLine();
        }

        foreach (var service in module.Services)
        {
            sb.AppendLine(GenerateService(service));
            sb.AppendLine();
        }

        foreach (var union in module.Definitions.OfType<IonUnion>())
        {
            sb.AppendLine(GenerateUnion(union));
            sb.AppendLine();
        }

        foreach (var attributeType in module.Attributes)
        {
            sb.AppendLine(GenerateAttributeDefinition(attributeType));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }

    private static string GenerateType(IonType type)
    {
        if (type is IonEnum enumType)
            return GenerateEnum(enumType);
        if (type is IonFlags flagsType)
            return GenerateFlags(flagsType);
        if (type is IonGenericType)
            return null;
        if (type.isTypedef)
            return GenerateTypedef(type);
        return GenerateMessage(type);
    }

    private static string GenerateEnum(IonEnum e)
    {
        var sb = new StringBuilder();
        sb.AppendLine("{compileGeneratedAttributes}");
        sb.AppendLine($"public enum {e.name.Identifier}");
        sb.AppendLine("{");
        foreach (var m in e.members)
            sb.AppendLine($"    {m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateFlags(IonFlags f)
    {
        var sb = new StringBuilder();
        sb.AppendLine("{compileGeneratedAttributes}");
        sb.AppendLine("[Flags]");
        sb.AppendLine($"public enum {f.name.Identifier} : {UnwrapType(f.baseType)}");
        sb.AppendLine("{");
        foreach (var m in f.members)
            sb.AppendLine($"    {m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateTypedef(IonType type)
    {
        var underlying = ResolveTypeName(type.fields.FirstOrDefault()?.type);
        return "{compileGeneratedAttributes}" +
               $"public readonly record struct {type.name.Identifier}({underlying} Value);";
    }

    private static string GenerateMessage(IonType type)
    {
        var sb = new StringBuilder();
        sb.AppendLine("{compileGeneratedAttributes}");
        sb.Append($"public sealed record {type.name.Identifier}(");
        sb.Append(string.Join(", ", type.fields.Select(f =>
            $"{GenerateField(f)}")));
        sb.AppendLine(");");
        return sb.ToString();
    }

    private static string GenerateService(IonService service)
    {
        var sb = new StringBuilder();
        sb.AppendLine("{compileGeneratedAttributes}");
        sb.AppendLine($"public interface I{service.name.Identifier} : IIonService");
        sb.AppendLine("{");

        foreach (var method in service.methods)
        {
            if (method.attributes.Any())
            {
                foreach (var attribute in method.attributes)
                {
                    if (attribute.name.Identifier.Equals("deprecated"))
                        sb.AppendLine("    [Obsolete]");
                    else
                        sb.AppendLine($"    [{attribute.name.Identifier}({string.Join(',', attribute.arguments)})]");
                }
            }

            var args = string.Join(", ",
                method.arguments.Select(GenerateArgument).Concat(["CancellationToken ct = default"]));
            sb.AppendLine($"    {GenerateReturnType(method)} {method.name.Identifier}({args});");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateField(IonField field) => $"{UnwrapType(field.type)} {field.name.Identifier}";

    private static string GenerateArgument(IonArgument arg)
    {
        if (arg.mod is IonArgumentModifiers.Stream)
            return $"IAsyncEnumerable<{UnwrapType(arg.type)}>?  {arg.name.Identifier}";
        return $"{UnwrapType(arg.type)} {arg.name.Identifier}";
    }

    private static string UnwrapType(IonType type) =>
        (type, UseMaybeWrapper) switch
        {
            (IonGenericType { IsMaybe: true } maybe, true) => $"IonMaybe<{ResolveTypeName(maybe.TypeArguments[0])}>",
            (IonGenericType { IsMaybe: true } maybe, false) => $"{ResolveTypeName(maybe.TypeArguments[0])}?",
            (IonGenericType { IsArray: true } array, _) => $"IonArray<{ResolveTypeName(array.TypeArguments[0])}>",
            (IonGenericType { IsPartial: true } partial, _) =>
                $"IonPartial<{ResolveTypeName(partial.TypeArguments[0])}>",
            (IonGenericType generic, _) => GenerateGenericTypeName(generic),
            _ => ResolveTypeName(type)
        };

    private static string GenerateGenericTypeName(IonGenericType generic)
        => $"{generic.name.Identifier}<{string.Join(',', generic.TypeArguments.Select(x => x.name.Identifier))}>";

    private static string ResolveTypeName(IonType type)
    {
        if (type is IonUnion union)
            return $"I{union.name.Identifier}";
        return type.name.Identifier;
    }

    private static string GenerateReturnType(IonMethod method)
    {
        if (method.returnType.IsVoid)
            return "Task";
        if (method.IsStreamable)
            return $"IAsyncEnumerable<{UnwrapType(method.returnType)}>";
        return $"Task<{UnwrapType(method.returnType)}>";
    }

    private string FormatterTemplate =>
        """
        {compileGeneratedAttributes}
        public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
        {
            {compileGeneratedAttributes}
            public {ionType} Read(CborReader reader)
            {
                var arraySize = reader.ReadStartArray() ?? throw new Exception("undefined len array not allowed");;
                {fieldReadExpression}
                reader.ReadEndArrayAndSkip(arraySize - {fieldsCount});
                return new({ctorFields});
            }
            
            {compileGeneratedAttributes}
            public void Write(CborWriter writer, {ionType} value)
            {
                writer.WriteStartArray({fieldsCount});
                {fieldWriteExpression}
                writer.WriteEndArray();
            }
        }
        """;

    private static string FormatterTemplateRef(IonType type)
    {
        if (type.IsVoid)
            throw new InvalidOperationException();
        return $"IonFormatterStorage<{UnwrapType(type)}>";
    }

    public string GenerateAllServiceExecutors(IEnumerable<IonService> service)
    {
        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var ionService in service)
        {
            sb.AppendLine(GenerateServiceExecutor(ionService));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }

    public string GenerateAllServiceClientImpl(IEnumerable<IonService> service)
    {
        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var ionService in service)
        {
            sb.AppendLine(GenerateServiceClientImpl(ionService));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }


    public string GenerateAllFormatters(IEnumerable<IonType> types)
    {
        var candidates = types.Where(t => t is
            { IsBuiltin: false, IsScalar: false, IsVoid: false, IsUnionCase: false, IsUnion: false }).ToArray();

        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());

        foreach (var t in candidates)
        {
            sb.AppendLine(GenerateFormatterForType(t));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }

    private static string GenerateFormatterForEnum(IonEnum @enum) =>
        """
            {compileGeneratedAttributes}
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                {compileGeneratedAttributes}
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }
                
                {compileGeneratedAttributes}
                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");

    private static string GenerateFormatterForFlags(IonFlags @enum) =>
        """
            {compileGeneratedAttributes}
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }

                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");


    private string GenerateFormatterForType(IonType type)
    {
        if (type is IonEnum @enum)
            return GenerateFormatterForEnum(@enum);
        if (type is IonFlags flags)
            return GenerateFormatterForFlags(flags);

        var name = type.name.Identifier;

        var template = FormatterTemplate
            .Replace("{ionType}", name)
            .Replace("{fieldReadExpression}", GenerateReadField(type))
            .Replace("{ctorFields}", GenerateCaptureField(type))
            .Replace("{fieldWriteExpression}", GenerateWriteField(type))
            .Replace("{fieldsCount}", type.fields.Count.ToString());

        return template;
    }

    private static string GenerateCaptureField(IonType type)
        => string.Join(", ", type.fields.Select(x => $"__{x.name.Identifier.ToLowerInvariant()}"));

    private static string GenerateCaptureField(IonMethod method, params string[] additional)
        => string.Join(", ", method.arguments.Select(x =>
        {
            if (x.mod is IonArgumentModifiers.Stream)
                return "inputStreamCasted";
            return $"__{x.name.Identifier.ToLowerInvariant()}";
        }).Concat(additional));

    private static string GenerateReadField(IonType type) =>
        string.Join($"\n{new string(' ', 8)}", type.fields.Select(GenerateReadField));

    private static string GenerateReadField(IonField field) =>
        field switch
        {
            { type: { IsArray: true } } => GenerateReadArrayField(field),
            { type: { IsMaybe: true } } => GenerateReadMaybeField(field),
            { type: { IsPartial: true } } => GenerateReadPartialField(field),
            _ => $"var __{field.name.Identifier.ToLowerInvariant()} = {FormatterTemplateRef(field.type)}.Read(reader);"
        };

    private static string GenerateReadArgument(IonArgument argument) =>
        argument switch
        {
            { type: { IsArray: true } } => GenerateReadArrayField(argument),
            { type: { IsMaybe: true } } => GenerateReadMaybeField(argument),
            { type: { IsPartial: true } } => GenerateReadPartialField(argument),
            _ =>
                $"var __{argument.name.Identifier.ToLowerInvariant()} = {FormatterTemplateRef(argument.type)}.Read(reader);"
        };


    private static string GenerateReadPartialField(IonArgument arg)
    {
        return "";
    }

    private static string GenerateWritePartialField(IonArgument arg)
    {
        return "";
    }


    private static string GenerateReadPartialField(IonField arg)
    {
        return "";
    }

    private static string GenerateWriteArgument(IonArgument argument) =>
        argument switch
        {
            { type: { IsArray: true } } => GenerateWriteArrayField(argument),
            { type: { IsMaybe: true } } => GenerateWriteMaybeField(argument),
            { type: { IsPartial: true } } => GenerateWritePartialField(argument),
            _ =>
                $"{FormatterTemplateRef(argument.type)}.Write(writer, __{argument.name.Identifier.ToLowerInvariant()});"
        };

    private static string GenerateReadArrayField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"var __{field.Name.Identifier.ToLowerInvariant()} = IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.ReadArray(reader);";
    }

    private static string GenerateReadMaybeField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        if (UseMaybeWrapper)
            return
                $"var __{field.Name.Identifier.ToLowerInvariant()} = IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.ReadMaybe(reader);";
        return
            $"var __{field.Name.Identifier.ToLowerInvariant()} = reader.ReadNullable<{ResolveTypeName(arrayType.TypeArguments[0])}>();";
    }


    private static string GenerateWriteArrayField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteArray(writer, __{field.Name.Identifier.ToLowerInvariant()});";
    }

    private static string GenerateWriteMaybeField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.{(UseMaybeWrapper ? "WriteMaybe" : "WriteNullable")}(writer, __{field.Name.Identifier.ToLowerInvariant()});";
    }

    private static string GenerateWriteReturnValue(IonType returnType) =>
        returnType switch
        {
            { IsArray: true } => GenerateWriteReturnValueForArray(returnType),
            { IsMaybe: true } => GenerateWriteReturnValueForMaybe(returnType),
            { IsPartial: true } => GenerateWriteReturnValueForPartial(returnType),
            _ => $"{FormatterTemplateRef(returnType)}.Write(writer, result);"
        };

    private static string GenerateWriteReturnValueForArray(IonType returnType)
    {
        if (returnType is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return $"{FormatterTemplateRef(arrayType.TypeArguments.First())}.WriteArray(writer, result);";
    }

    private static string GenerateWriteReturnValueForPartial(IonType returnType)
    {
        return "";
    }

    private static string GenerateWriteReturnValueForMaybe(IonType returnType)
    {
        if (returnType is not IonGenericType { IsMaybe: true } maybeType)
            throw new InvalidOperationException();
        return
            $"{FormatterTemplateRef(maybeType.TypeArguments.First())}.{(UseMaybeWrapper ? "WriteMaybe" : "WriteNullable")}(writer, result);";
    }

    private static string GenerateWriteField(IonType type)
        => string.Join($"\n{new string(' ', 8)}", type.fields.Select(GenerateWriteField));

    private static string GenerateWriteField(IonField field)
    {
        return field switch
        {
            { type: { IsArray: true } } => GenerateWriteArrayField(field),
            { type: { IsMaybe: true } } => GenerateWriteMaybeField(field),
            _ => $"{FormatterTemplateRef(field.type)}.Write(writer, value.{field.name.Identifier});"
        };
    }

    private static string GenerateReadArguments(IonMethod method)
        => string.Join($"\n{new string(' ', 8)}",
            method.arguments.Where(x => x.mod is not IonArgumentModifiers.Stream).Select(GenerateReadArgument));

    private static string GenerateWriteArguments(IonMethod method)
        => string.Join($"\n{new string(' ', 8)}", method.arguments.Where(x => x.mod is not IonArgumentModifiers.Stream).Select(GenerateWriteArgument));

    private static string GenerateWriteArrayField(IonField field)
    {
        if (field.type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.WriteArray(writer, value.{field.name.Identifier});";
    }

    private static string GenerateWriteMaybeField(IonField field)
    {
        if (field.type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage<{ResolveTypeName(arrayType.TypeArguments[0])}>.{(UseMaybeWrapper ? "WriteMaybe" : "WriteNullable")}(writer, value.{field.name.Identifier});";
    }

    private static readonly string ServiceExecutorTemplate =
        """
        public sealed class Ion_{serviceTypename}_ServiceExecutor(AsyncServiceScope scope) : {routerInterfaces}
        {
            {body}
            
            {routerStreaming}
            
            {routerUnary}
            
            private static readonly string[] __allowedStreamingMethods = [
                {allowedInputStreamMethods}
            ];
            
            public bool IsAllowInputStream(string methodName) => __allowedStreamingMethods.Contains(methodName);
        }
        """;

    private static readonly string RouterStreamMethodTemplate =
        """
            public IAsyncEnumerable<Memory<byte>> StreamRouteExecuteAsync(string methodName, CborReader reader, IAsyncEnumerable<ReadOnlyMemory<byte>>? inputStream, [EnumeratorCancellation] CancellationToken ct)
            {
                {serviceStreamRouteBranch}
                
                throw new InvalidOperationException("no method defined");
            }
        """;

    private static readonly string RouterMethodTemplate =
        """
            public Task RouteExecuteAsync(string methodName, CborReader reader, CborWriter writer, CancellationToken ct = default)
            {
                {serviceRouteBranch}
                
                throw new InvalidOperationException("no method defined");
            }
        """;

    private static readonly string CastedInputStreamTemplate =
        """
        var inputStreamCasted = inputStream is null
        ? null
        : inputStream.Select(bytes =>
        {
            var reader = new CborReader(bytes);
            var arr = reader.ReadStartArray();
            var result = IonFormatterStorage<{inputStreamType}>.Read(reader);
            reader.ReadEndArray();

            return result;
        });
        """;

    private static readonly string ServiceStreamExecutorMethodTemplate =
        """
            public async IAsyncEnumerable<Memory<byte>> {methodName}_Execute(CborReader reader, IAsyncEnumerable<ReadOnlyMemory<byte>>? inputStream, CancellationToken ct = default)
            {
                var service = scope.ServiceProvider.GetRequiredService<I{serviceTypename}>();

                const int argumentSize = {argSize};
                
                {inputCastedStream}

                var arraySize = reader.ReadStartArray() ?? throw new Exception("undefined len array not allowed");
                    
                {fieldReadExpression}

                reader.ReadEndArrayAndSkip(arraySize - argumentSize);

                await foreach (var e in service.{methodName}({fieldReadArgs}))
                {
                    var writer = new CborWriter();

                    IonFormatterStorage<{returnType}>.Write(writer, e);

                    var mem = MemoryPool<byte>.Shared.Rent(writer.BytesWritten);

                    writer.Encode(mem.Memory.Span);

                    yield return mem.Memory;

                    mem.Dispose();
                }
            }
        """;

    private static readonly string ServiceExecutorMethodNoReturnTemplate =
        """
            {compileGeneratedAttributes}
            public async Task {methodName}_Execute(CborReader reader, CborWriter writer, CancellationToken ct = default)
            {
                var service = scope.ServiceProvider.GetRequiredService<I{serviceTypename}>();
            
                const int argumentSize = {argSize};
            
                var arraySize = reader.ReadStartArray() ?? throw new Exception("undefined len array not allowed");
            
                {fieldReadExpression}
            
                reader.ReadEndArrayAndSkip(arraySize - argumentSize);
            
                await service.{methodName}({fieldReadArgs});
            }
        """;

    private static readonly string ServiceExecutorMethodWithReturnTemplate =
        """
            {compileGeneratedAttributes}
            public async Task {methodName}_Execute(CborReader reader, CborWriter writer, CancellationToken ct = default)
            {
                var service = scope.ServiceProvider.GetRequiredService<I{serviceTypename}>();
            
                const int argumentSize = {argSize};
            
                var arraySize = reader.ReadStartArray() ?? throw new Exception("undefined len array not allowed");
            
                {fieldReadExpression}
            
                reader.ReadEndArrayAndSkip(arraySize - argumentSize);
            
                var result = await service.{methodName}({fieldReadArgs});
                
                {writeResultExpression}
            }
        """;

    private static readonly string ServiceBranchExecute =
        """
                if (methodName.Equals("{methodName}", StringComparison.InvariantCultureIgnoreCase))
                    return {methodName}_Execute(reader, writer, ct);
        """;

    private static readonly string ServiceStreamBranchExecute =
        """
                if (methodName.Equals("{methodName}", StringComparison.InvariantCultureIgnoreCase))
                    return {methodName}_Execute(reader, inputStream, ct);
        """;

    private string GenerateServiceExecutor(IonService service)
    {
        var interfaces = "";
        if (service.methods.Any(x => x.IsStreamable) && service.methods.Any(x => !x.IsStreamable))
            interfaces = "IServiceExecutorRouter, IServiceStreamExecutorRouter";
        else if (service.methods.All(x => x.IsStreamable))
            interfaces = "IServiceStreamExecutorRouter";
        else
            interfaces = "IServiceExecutorRouter";

        var methodsBuilder = new StringBuilder();
        var branchBuilder = new StringBuilder();
        var branchStreamBuilder = new StringBuilder();
        var serviceTypename = service.name.Identifier;
        var builder = ServiceExecutorTemplate
            .Replace("{serviceTypename}", serviceTypename)
            .Replace("{routerInterfaces}", interfaces)
            .Replace("{routerStreaming}",
                interfaces.Contains("IServiceStreamExecutorRouter") ? $"\n{RouterStreamMethodTemplate}" : "")
            .Replace("{routerUnary}", interfaces.Contains("IServiceExecutorRouter") ? RouterMethodTemplate : "");


        var allowedInputStreamMethods = service.methods
            .Where(x => x.arguments.Any(a => a.mod is IonArgumentModifiers.Stream))
            .Select(x => x.name.Identifier)
            .ToList();

        builder = builder.Replace("{allowedInputStreamMethods}",
            allowedInputStreamMethods.Count != 0
                ? string.Join(",", allowedInputStreamMethods.Select(x => $"\"{x}\""))
                : "");

        branchBuilder.AppendLine();
        methodsBuilder.AppendLine();
        branchStreamBuilder.AppendLine();

        foreach (var method in service.methods)
        {
            if (method.IsStreamable)
                GenerateStreamMethodExecutor(method, serviceTypename, methodsBuilder, branchStreamBuilder);
            else
                GenerateUnaryMethodExecutor(method, serviceTypename, methodsBuilder, branchBuilder);
        }

        return builder
            .Replace("{body}", methodsBuilder.ToString())
            .Replace("{serviceRouteBranch}", branchBuilder.ToString())
            .Replace("{serviceStreamRouteBranch}", branchStreamBuilder.ToString());
    }

    private static void GenerateStreamMethodExecutor(IonMethod method, string serviceTypename,
        StringBuilder methodsBuilder,
        StringBuilder branchBuilder)
    {
        var methodName = method.name.Identifier;
        var argSize = method.arguments.Count(x => x.mod is not IonArgumentModifiers.Stream);

        var readArgsExpression = GenerateReadArguments(method);
        var captureArgsExpression = GenerateCaptureField(method, "ct");

        var template = ServiceStreamExecutorMethodTemplate;

        var inputStreamArg = method.arguments.FirstOrDefault(x => x.mod is IonArgumentModifiers.Stream);

        if (inputStreamArg is not null)
        {
            template = template.Replace("{inputCastedStream}",
                CastedInputStreamTemplate
                    .Replace("{inputStreamType}", UnwrapType(inputStreamArg.Type))
                );
        }
        else
            template = template.Replace("{inputCastedStream}", "");

        var templateMethod =
            template
                .Replace("{serviceTypename}", serviceTypename)
                .Replace("{methodName}", methodName)
                .Replace("{argSize}", argSize.ToString())
                .Replace("{fieldReadExpression}", readArgsExpression)
                .Replace("{fieldReadArgs}", captureArgsExpression)
                .Replace("{returnType}", UnwrapType(method.returnType));

        methodsBuilder.AppendLine(templateMethod);


        var branch = ServiceStreamBranchExecute
            .Replace("{methodName}", methodName);

        branchBuilder.AppendLine(branch);
    }

    private static void GenerateUnaryMethodExecutor(IonMethod method, string serviceTypename,
        StringBuilder methodsBuilder,
        StringBuilder branchBuilder)
    {
        var methodName = method.name.Identifier;
        var argSize = method.arguments.Count;

        var readArgsExpression = GenerateReadArguments(method);
        var captureArgsExpression = GenerateCaptureField(method);

        var template = method.returnType.IsVoid
            ? ServiceExecutorMethodNoReturnTemplate
            : ServiceExecutorMethodWithReturnTemplate;

        var templateMethod =
            template
                .Replace("{serviceTypename}", serviceTypename)
                .Replace("{methodName}", methodName)
                .Replace("{argSize}", argSize.ToString())
                .Replace("{fieldReadExpression}", readArgsExpression)
                .Replace("{fieldReadArgs}", captureArgsExpression);

        if (!method.returnType.IsVoid)
            templateMethod = templateMethod
                .Replace("{writeResultExpression}", GenerateWriteReturnValue(method.returnType));

        methodsBuilder.AppendLine(templateMethod);


        var branch = ServiceBranchExecute
            .Replace("{methodName}", methodName);

        branchBuilder.AppendLine(branch);
    }


    private static readonly string ServiceClientImplTemplate =
        """
        {compileGeneratedAttributes}
        public sealed class Ion_{serviceTypename}_ClientImpl(IonClientContext context) : I{serviceTypename}
        {
            {MethodInfoDecls}

            {body}
        }
        """;

    private static readonly string ServiceClientMethodInfoDecl =
        """
            private static readonly Lazy<MethodInfo> {methodName}_Ref = new(() =>
                typeof(I{serviceTypename}).GetMethod(nameof({methodName}), BindingFlags.Public | BindingFlags.Instance)!);
        """;

    private static readonly string ServiceClientMethodDecl =
        """
            {compileGeneratedAttributes}
            public async Task<{methodReturnType}> {methodName}({args})
            {
                var req = new IonRequest(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);
            
                var writer = new CborWriter();
                
                const int argsSize = {argSize};
            
                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();
            
                return await req.CallAsync<{methodReturnType}>(writer.Encode(), ct: ct);
            }
        """;

    private static readonly string ServiceClientMethodDeclArray =
        """
            {compileGeneratedAttributes}
            public async Task<{methodReturnType}> {methodName}({args})
            {
                var req = new IonRequest(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);
            
                var writer = new CborWriter();
                
                const int argsSize = {argSize};
            
                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();
            
                return await req.CallAsyncWithArray<{methodReturnTypeUnwrapped}>(writer.Encode(), ct: ct);
            }
        """;

    private static readonly string ServiceClientMethodDeclNullable =
        """
            {compileGeneratedAttributes}
            public async Task<{methodReturnType}> {methodName}({args})
            {
                var req = new IonRequest(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);
            
                var writer = new CborWriter();
                
                const int argsSize = {argSize};
            
                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();
            
                return await req.CallAsyncNullable<{methodReturnTypeUnwrapped}>(writer.Encode(), ct: ct);
            }
        """;

    private static readonly string ServiceClientMethodDeclNoReturn =
        """
            {compileGeneratedAttributes}
            public async Task {methodName}({args})
            {
                var req = new IonRequest(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);

                var writer = new CborWriter();
                
                const int argsSize = {argSize};

                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();

                await req.CallAsync(writer.Encode(), ct: ct);
            }
        """;

    private static readonly string ServiceClientMethodDeclStream =
        """
            public IAsyncEnumerable<{methodReturnType}> {methodName}({args})
            {
                var ws = new IonWsClient(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);
            
                var writer = new CborWriter();

                const int argsSize = {argSize};
                
                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();
            
                return {streamReturnMatched};
            }
        """;

    private string GenerateServiceClientImpl(IonService service)
    {
        var methodsBuilder = new StringBuilder();
        var methodInfoDecl = new StringBuilder();
        var serviceTypename = service.name.Identifier;
        var builder = ServiceClientImplTemplate;

        methodInfoDecl.AppendLine();
        methodsBuilder.AppendLine();

        foreach (var method in service.methods)
        {
            var methodName = method.name.Identifier;
            var argSize = method.arguments.Count(x => x.mod is not IonArgumentModifiers.Stream);

            var writeArgsExpression = GenerateWriteArguments(method);

            var methodArgs = string.Join(", ", method.arguments.Select(GenerateClientMethodArgument).Concat(["CancellationToken ct = default"]));

            var template =
                method.IsStreamable
                    ? ServiceClientMethodDeclStream
                    : method.returnType.IsVoid
                        ? ServiceClientMethodDeclNoReturn
                        : method.returnType.IsArray
                            ? ServiceClientMethodDeclArray
                            : method.returnType.IsMaybe
                                ? ServiceClientMethodDeclNullable
                                : ServiceClientMethodDecl;

            var inputStreamArg = method.arguments.FirstOrDefault(x => x.mod is IonArgumentModifiers.Stream);
            if (method.IsStreamable && inputStreamArg is not null)
                template = template.Replace("{streamReturnMatched}",
                    $"ws.CallServerStreamingAsync<{{methodReturnType}}, {UnwrapType(inputStreamArg.Type)}>(writer.Encode(), inputStream, ct: ct)");
            else
                template = template.Replace("{streamReturnMatched}",
                    "ws.CallServerStreamingAsync<{methodReturnType}>(writer.Encode(), ct: ct)");


            var templateMethod =
                    template
                        .Replace("{serviceTypename}", serviceTypename)
                        .Replace("{methodName}", methodName)
                        .Replace("{argSize}", argSize.ToString())
                        .Replace("{argsWrite}", writeArgsExpression)
                        .Replace("{args}", methodArgs);

            if (method.returnType is { IsVoid: false })
                templateMethod = templateMethod
                    .Replace("{methodReturnType}", UnwrapType(method.returnType));
            if (method.returnType is { IsVoid: false, IsArray: true })
                templateMethod = templateMethod
                    .Replace("{methodReturnTypeUnwrapped}",
                        ResolveTypeName((method.returnType as IonGenericType)!.TypeArguments[0]));
            if (method.returnType is { IsVoid: false, IsArray: false, IsMaybe: true })
                templateMethod = templateMethod
                    .Replace("{methodReturnTypeUnwrapped}",
                        ResolveTypeName((method.returnType as IonGenericType)!.TypeArguments[0]));

            methodsBuilder.AppendLine(templateMethod);


            var methodInfoDeclaration =
                ServiceClientMethodInfoDecl
                    .Replace("{methodName}", methodName)
                    .Replace("{serviceTypename}", serviceTypename);


            methodInfoDecl.AppendLine(methodInfoDeclaration);
        }

        return builder
            .Replace("{MethodInfoDecls}", methodInfoDecl.ToString())
            .Replace("{body}", methodsBuilder.ToString())
            .Replace("{serviceTypename}", serviceTypename);

        static string GenerateClientMethodArgument(IonArgument field)
        {
            if (field.mod is IonArgumentModifiers.Stream)
                return $"IAsyncEnumerable<{UnwrapType(field.type)}> inputStream";

            return $"{UnwrapType(field.type)} __{field.name.Identifier.ToLowerInvariant()}";
        }
    }

    private static readonly string AttributeTemplate =
        """
        [AttributeUsage(AttributeTargets.All)]
        public sealed class {AttributeName}Attribute({args}) : System.Attribute
        {
        {argValues}
        }
        """;

    private string GenerateAttributeDefinition(IonAttributeType type)
    {
        var accessValues = new StringBuilder();

        foreach (var argument in type.arguments)
            accessValues.AppendLine(
                $"    public {UnwrapType(argument.type)} {argument.Name.Identifier.Capitalize()} => {argument.Name.Identifier};");

        return AttributeTemplate
            .Replace("{argValues}", accessValues.ToString())
            .Replace("{args}", string.Join(", ", type.arguments.Select(GenerateArgument)))
            .Replace("{AttributeName}", type.name.Identifier);
    }

    private string GenerateUnion(IonUnion union)
    {
        var builder = new StringBuilder();

        var unionInterface =
            Union_InterfaceBody
                .Replace("{checkProps}", GenerateUnionCheckProps(union))
                .Replace("{unionName}", union.name.Identifier);


        builder.AppendLine();
        builder.AppendLine(unionInterface);


        var cases = GenerateUnionCase(union, out var targetTypesForFormatterGeneration);

        builder.AppendLine();
        builder.AppendLine(cases);

        builder.AppendLine();
        builder.AppendLine(GenerateUnionFormatterFraction(union));

        foreach (var ionType in targetTypesForFormatterGeneration)
        {
            //builder.AppendLine();
            //builder.AppendLine(GenerateMessage(ionType));
            builder.AppendLine();
            builder.AppendLine(GenerateFormatterForType(ionType));
        }

        return builder.ToString();
    }

    private string GenerateUnionCheckProps(IonUnion union)
    {
        var builder = new StringBuilder();

        foreach (var checkType in union.types)
        {
            builder.AppendLine();
            builder.AppendLine(Union_InterfaceBody_CheckProp
                .Replace("{caseTypeName}", checkType.name.Identifier));
        }

        return builder.ToString();
    }

    private string GenerateUnionCase(IonUnion union, out List<IonType> unionTypesRequiredFormatters)
    {
        unionTypesRequiredFormatters = new();
        var builder = new StringBuilder();
        var index = 0;
        foreach (var type in union.types)
        {
            if (!type.IsUnionCase)
            {
                index++;
                continue;
            }

            unionTypesRequiredFormatters.Add(type);

            var fields = string.Join(", ", type.fields.Select(f =>
                $"{GenerateField(f)}"));

            builder.AppendLine();
            builder.AppendLine(Union_CaseBody
                .Replace("{fields}", fields)
                .Replace("{caseTypeName}", type.name.Identifier)
                .Replace("{unionName}", union.name.Identifier)
                .Replace("{caseIndex}", index.ToString())
            );

            index++;
        }

        return builder.ToString();
    }

    private static readonly string Union_InterfaceBody =
        """
        {compileGeneratedAttributes}
        public interface I{unionName} : IIonUnion<I{unionName}>
        {
            string UnionKey { get; }
            uint UnionIndex { get; }
            
            {checkProps}
        }
        """;

    private static readonly string Union_InterfaceBody_CheckProp =
        """
            internal bool Is{caseTypeName} => this is {caseTypeName};
        """;

    private static readonly string Union_CaseBody =
        """
        {compileGeneratedAttributes}
        public sealed record {caseTypeName}({fields}) : I{unionName}
        {
            public string UnionKey => nameof({caseTypeName});
            public uint UnionIndex => {caseIndex};
        }
        """;

    private string GenerateUnionFormatterFraction(IonUnion union)
    {
        var builder = new StringBuilder();

        var writeChecks = new StringBuilder();
        var readChecks = new StringBuilder();
        var index = 0;
        foreach (var @case in union.types)
        {
            writeChecks.AppendLine();
            writeChecks.AppendLine(
                UnionWriteCheck
                    .Replace("{caseTypeName}", @case.name.Identifier)
                    .Replace("{caseIndex}", index.ToString())
            );


            readChecks.AppendLine();
            readChecks.AppendLine(
                UnionReadCheck
                    .Replace("{caseTypeName}", @case.name.Identifier)
                    .Replace("{caseIndex}", index.ToString())
            );

            index++;
        }


        builder.AppendLine();
        builder.AppendLine(Union_InterfaceFormatter
            .Replace("{unionInterface}", union.name.Identifier)
            .Replace("{readCheks}", readChecks.ToString())
            .Replace("{writeChecks}", writeChecks.ToString())
        );

        return builder.ToString();
    }


    private static readonly string Union_InterfaceFormatter =
        """
        {compileGeneratedAttributes}
        public sealed class Ion_I{unionInterface}_Formatter : IonFormatter<I{unionInterface}>
        {
            public I{unionInterface} Read(CborReader reader)
            {
                var arraySize = reader.ReadStartArray() ?? throw new Exception("undefined len array not allowed");
                var unionIndex = reader.ReadUInt32();
                I{unionInterface} result;
                if (false) {}
                {readCheks}
                else
                    throw new InvalidOperationException();
                reader.ReadEndArray();
                return result;
            }

            public void Write(CborWriter writer, I{unionInterface} value)
            {
                writer.WriteStartArray(2);
                writer.WriteUInt32(value.UnionIndex);

                if (false) {}
                {writeChecks}    
                else
                    throw new InvalidOperationException();
                writer.WriteEndArray();    
            }
        }
        """;

    private static readonly string UnionReadCheck =
        """
                else if (unionIndex == {caseIndex})
                    result = IonFormatterStorage<{caseTypeName}>.Read(reader);
        """;

    private static readonly string UnionWriteCheck =
        """
                else if (value is {caseTypeName} n_{caseIndex})
                {
                    if (n_{caseIndex}.UnionIndex != {caseIndex})
                        throw new InvalidOperationException();
                    IonFormatterStorage<{caseTypeName}>.Write(writer, n_{caseIndex});
                }
        """;
}

public static class StringEx
{
    public static string Capitalize(this string input)
    {
        if (string.IsNullOrEmpty(input))
            return input;

        return char.ToUpper(input[0]) + input[1..];
    }
}