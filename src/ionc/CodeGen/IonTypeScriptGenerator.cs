namespace ion.compiler.CodeGen;

using ion.runtime;
using Microsoft.Build.Construction;
using Microsoft.Build.Evaluation;
using syntax;
using System.Text;
public class IonTypeScriptGenerator(string @namespace) : IIonCodeGenerator
{
    public string FileHeader()
    {
        return $"""
                //------------------------------------------------------------------------------
                // <auto-generated>
                //     This code was generated by a code generation tool.
                //     Changes to this file may cause incorrect behavior and will be lost
                //     if the code is regenerated.
                //
                //     Generator: IonPath Codegen
                // </auto-generated>
                //------------------------------------------------------------------------------
                """;
    }

    public void GenerateProjectFile(string projectName, FileInfo outputFile)
    {
        throw new NotImplementedException();
    }

    public string GenerateModuleInit(IEnumerable<IonType> types, IReadOnlyList<IonService> services, bool clientToo, bool serverToo)
    {
        throw new NotImplementedException();
    }

    public string GenerateModule(IonModule module)
    {
        throw new NotImplementedException();
    }

    public string GenerateAllServiceExecutors(IEnumerable<IonService> service)
    {
        throw new NotImplementedException();
    }

    public string GenerateTypes(IEnumerable<IonType> types)
    {
        var sb = new StringBuilder();
        sb.AppendLine();

        var allTypes = types.ToList();

        foreach (var type in allTypes.Where(type => type is { IsUnionCase: false, IsUnion: false }))
        {
            sb.AppendLine(GenerateType(type));
            sb.AppendLine();
        }
        foreach (var union in allTypes.OfType<IonUnion>())
        {
            sb.AppendLine(GenerateUnion(union));
            sb.AppendLine();
        }

        return sb.ToString();
    }

    public string GenerateServices(IonModule module)
    {
        var sb = new StringBuilder();
        sb.AppendLine();
        foreach (var service in module.Services)
        {
            sb.AppendLine(GenerateService(service));
            sb.AppendLine();
        }
        return sb.ToString();
    }

    private static string GenerateType(IonType type)
    {
        if (type is IonEnum enumType)
            return GenerateEnum(enumType);
        if (type is IonFlags flagsType)
            return GenerateFlags(flagsType);
        if (type is IonGenericType)
            return null;
        if (type.isTypedef)
            return GenerateTypedef(type);
        return GenerateMessage(type);
    }

    private static string GenerateEnum(IonEnum e)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"export enum {e.name.Identifier}");
        sb.AppendLine("{");
        foreach (var m in e.members)
            sb.AppendLine($"{new string(' ', 2)}{m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateFlags(IonFlags f)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"export enum {f.name.Identifier}");
        sb.AppendLine("{");
        foreach (var m in f.members)
            sb.AppendLine($"{new string(' ', 2)}{m.name.Identifier} = {m.constantValue},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateTypedef(IonType type)
    {
        var underlying = ResolveTypeName(type.fields.FirstOrDefault()?.type);
        return $"export type {type.name.Identifier} = {underlying};";
    }

    private static string GenerateMessage(IonType type)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"export interface {type.name.Identifier} {{");
        foreach (var typeField in type.fields)
        {
            sb.AppendLine($"{new string(' ', 2)}{GenerateField(typeField)};");
        }
        sb.AppendLine("};");
        return sb.ToString();
    }

    private static string GenerateService(IonService service)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"export interface I{service.name.Identifier} extends IIonService");
        sb.AppendLine("{");

        foreach (var method in service.methods)
        {
            var args = string.Join(", ", method.arguments.Select(GenerateArgument));
            sb.AppendLine($"{new string(' ', 2)}{method.name.Identifier}({args}): {GenerateReturnType(method)};");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateField(IonField field) => $"{field.name.Identifier}: {UnwrapType(field.type)}";

    private static string GenerateArgument(IonArgument field) => $"{field.name.Identifier}: {UnwrapType(field.type)}";

    private static string UnwrapType(IonType type) => type switch
    {
        IonGenericType { IsMaybe: true } maybe => $"IonMaybe<{ResolveTypeName(maybe.TypeArguments[0])}>",
        IonGenericType { IsArray: true } array => $"IonArray<{ResolveTypeName(array.TypeArguments[0])}>",
        IonGenericType generic => GenerateGenericTypeName(generic),
        _ => ResolveTypeName(type)
    };

    private static string GenerateGenericTypeName(IonGenericType generic)
        => $"{generic.name.Identifier}<{string.Join(',', generic.TypeArguments.Select(x => x.name.Identifier))}>";

    private static string ResolveTypeName(IonType type)
    {
        if (type is IonUnion union)
            return $"I{union.name.Identifier}";
        return type.name.Identifier;
    }

    private static string GenerateReturnType(IonMethod method)
    {
        if (method.returnType.IsVoid)
            return "Promise<void>";
        if (method.IsStreamable)
            return $"AsyncIterable<{UnwrapType(method.returnType)}>";
        return $"Promise<{UnwrapType(method.returnType)}>";
    }

    private string FormatterTemplate =>
        """
        IonFormatterStorage.register("{ionType}", {
          read(reader: CborReader): {ionType} {
            reader.readStartArray();
            {fieldReadExpression}
            reader.readEndArray();
            return { {ctorFields} };
          },
          write(writer: CborWriter, value: {ionType}): void {
            writer.writeStartArray(null);
            {fieldWriteExpression}
            writer.writeEndArray();
          }
        });
        """;

    private string FormatterTemplateForUnion =>
        """
        IonFormatterStorage.register("{ionType}", {
          read(reader: CborReader): {ionType} {
            reader.readStartArray();
            {fieldReadExpression}
            reader.readEndArray();
            return new {ionType}({ctorFields});
          },
          write(writer: CborWriter, value: {ionType}): void {
            writer.writeStartArray(null);
            {fieldWriteExpression}
            writer.writeEndArray();
          }
        });
        """;

    private static string FormatterTemplateRef(IonType type)
    {
        if (type.IsVoid)
            throw new InvalidOperationException();
        return $"IonFormatterStorage.get<{UnwrapType(type)}>('{UnwrapType(type)}')";
    }

    public string GenerateAllServiceClientImpl(IEnumerable<IonService> service)
    {
        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var ionService in service)
        {
            sb.AppendLine(GenerateServiceClientImpl(ionService));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }

    public string GenerateGlobalTypes()
    {
        throw new NotImplementedException();
    }


    public string GenerateAllFormatters(IEnumerable<IonType> types)
    {
        var candidates = types.Where(t => t is { IsBuiltin: false, IsScalar: false, IsVoid: false, IsUnionCase: false, IsUnion: false }).ToArray();
        var sorted = TopoSortByDependencies(candidates);

        var sb = new StringBuilder();

        sb.AppendLine(FileHeader());

        foreach (var t in sorted)
        {
            sb.AppendLine(GenerateFormatterForType(t));
            sb.AppendLine();
        }

        return sb.ToCompiledString();
    }

    private static string GenerateFormatterForEnum(IonEnum @enum) =>
        """
            {compileGeneratedAttributes}
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                {compileGeneratedAttributes}
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }
                
                {compileGeneratedAttributes}
                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");

    private static string GenerateFormatterForFlags(IonFlags @enum) =>
        """
            {compileGeneratedAttributes}
            public sealed class Ion_{ionType}_Formatter : IonFormatter<{ionType}>
            {
                public {ionType} Read(CborReader reader)
                {
                     return ({ionType})({readEnumValue}.Read(reader));
                }

                public void Write(CborWriter writer, {ionType} value)
                {
                    var casted = ({baseTypeName})value;
                    {writeEnumValue}
                }
            }
            """
            .Replace("{ionType}", @enum.name.Identifier)
            .Replace("{baseTypeName}", @enum.baseType.name.Identifier)
            .Replace("{readEnumValue}", FormatterTemplateRef(@enum.baseType))
            .Replace("{writeEnumValue}", $"{FormatterTemplateRef(@enum.baseType)}.Write(writer, casted);");


    private string GenerateFormatterForType(IonType type)
    {
        if (type is IonEnum @enum)
            return GenerateFormatterForEnum(@enum);
        if (type is IonFlags flags)
            return GenerateFormatterForFlags(flags);

        var name = type.name.Identifier;

        var template = (type.IsUnionCase ? FormatterTemplateForUnion : FormatterTemplate)
            .Replace("{ionType}", name)
            .Replace("{fieldReadExpression}", GenerateReadField(type))
            .Replace("{ctorFields}", GenerateCaptureField(type))
            .Replace("{fieldWriteExpression}", GenerateWriteField(type));

        return template;
    }

    private static string GenerateCaptureField(IonType type)
        => string.Join(", ", type.fields.Select(x => $"{x.name.Identifier}"));

    private static string GenerateCaptureField(IonMethod method)
        => string.Join(", ", method.arguments.Select(x => $"{x.name.Identifier}"));

    private static string GenerateReadField(IonType type) =>
        string.Join($"\n{new string(' ', 4)}", type.fields.Select(GenerateReadField));

    private static string GenerateReadField(IonField field) =>
        field switch
        {
            { type: { IsArray: true } } => GenerateReadArrayField(field),
            { type: { IsMaybe: true } } => GenerateReadMaybeField(field),
            _ => $"const {field.name.Identifier} = {FormatterTemplateRef(field.type)}.read(reader);"
        };

    private static string GenerateReadArgument(IonArgument argument) =>
        argument switch
        {
            { type: { IsArray: true } } => GenerateReadArrayField(argument),
            { type: { IsMaybe: true } } => GenerateReadMaybeField(argument),
            _ =>
                $"const {argument.name.Identifier} = {FormatterTemplateRef(argument.type)}.read(reader);"
        };


    private static string GenerateWriteArgument(IonArgument argument) =>
        argument switch
        {
            { type: { IsArray: true } } => GenerateWriteArrayField(argument),
            { type: { IsMaybe: true } } => GenerateWriteMaybeField(argument),
            _ =>
                $"{FormatterTemplateRef(argument.type)}.write(writer, {argument.name.Identifier});"
        };

    private static string GenerateReadArrayField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"const {field.Name.Identifier} = IonFormatterStorage.readArray<{ResolveTypeName(arrayType.TypeArguments[0])}>(reader, '{ResolveTypeName(arrayType.TypeArguments[0])}');";
    }

    private static string GenerateReadMaybeField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"const {field.Name.Identifier} = IonFormatterStorage.readMaybe<{ResolveTypeName(arrayType.TypeArguments[0])}>(reader, '{ResolveTypeName(arrayType.TypeArguments[0])}');";
    }


    private static string GenerateWriteArrayField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage.writeArray<{ResolveTypeName(arrayType.TypeArguments[0])}>(writer, {field.Name.Identifier});";
    }

    private static string GenerateWriteMaybeField(ITypeWithName field)
    {
        if (field.Type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage.writeMaybe<{ResolveTypeName(arrayType.TypeArguments[0])}>(writer, {field.Name.Identifier});";
    }

    private static string GenerateWriteReturnValue(IonType returnType) =>
        returnType switch
        {
            { IsArray: true } => GenerateWriteReturnValueForArray(returnType),
            { IsMaybe: true } => GenerateWriteReturnValueForMaybe(returnType),
            _ => $"{FormatterTemplateRef(returnType)}.write(writer, result);"
        };

    private static string GenerateWriteReturnValueForArray(IonType returnType)
    {
        if (returnType is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return $"{FormatterTemplateRef(arrayType.TypeArguments.First())}.writeArray(writer, result, '{FormatterTemplateRef(arrayType.TypeArguments.First())}');";
    }

    private static string GenerateWriteReturnValueForMaybe(IonType returnType)
    {
        if (returnType is not IonGenericType { IsMaybe: true } maybeType)
            throw new InvalidOperationException();
        return $"{FormatterTemplateRef(maybeType.TypeArguments.First())}.writeMaybe(writer, result, '{FormatterTemplateRef(arrayType.TypeArguments.First())}');";
    }

    private static string GenerateWriteField(IonType type)
        => string.Join($"\n{new string(' ', 4)}", type.fields.Select(GenerateWriteField));

    private static string GenerateWriteField(IonField field)
    {
        return field switch
        {
            { type: { IsArray: true } } => GenerateWriteArrayField(field),
            { type: { IsMaybe: true } } => GenerateWriteMaybeField(field),
            _ => $"{FormatterTemplateRef(field.type)}.write(writer, value.{field.name.Identifier});"
        };
    }

    private static string GenerateReadArguments(IonMethod method)
        => string.Join($"\n{new string(' ', 4)}", method.arguments.Select(GenerateReadArgument));

    private static string GenerateWriteArguments(IonMethod method)
        => string.Join($"\n{new string(' ', 4)}", method.arguments.Select(GenerateWriteArgument));

    private static string GenerateWriteArrayField(IonField field)
    {
        if (field.type is not IonGenericType { IsArray: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage.writeArray<{ResolveTypeName(arrayType.TypeArguments[0])}>(writer, value.{field.name.Identifier});";
    }

    private static string GenerateWriteMaybeField(IonField field)
    {
        if (field.type is not IonGenericType { IsMaybe: true } arrayType)
            throw new InvalidOperationException();
        return
            $"IonFormatterStorage.writeMaybe<{ResolveTypeName(arrayType.TypeArguments[0])}>(writer, value.{field.name.Identifier});";
    }

    private static IReadOnlyList<IonType> TopoSortByDependencies(IReadOnlyList<IonType> types)
    {
        var byName = types.ToDictionary(t => t.name.Identifier, t => t);
        var visited = new HashSet<string>();
        var temp = new HashSet<string>();
        var result = new List<IonType>();

        foreach (var t in types) Visit(t);
        return result;

        void Visit(IonType t)
        {
            var key = t.name.Identifier;
            if (visited.Contains(key)) return;
            if (!temp.Add(key)) return;

            foreach (var f in t.fields ?? [])
            {
                var ft = f.type;
                if (ft is null || ft.IsBuiltin || ft.IsScalar || ft.IsVoid) continue;
                if (byName.TryGetValue(ft.name.Identifier, out var dep))
                    Visit(dep);
            }

            temp.Remove(key);
            visited.Add(key);
            result.Add(t);
        }
    }


    private static readonly string ServiceClientImplTemplate =
        """
        {compileGeneratedAttributes}
        public sealed class Ion_{serviceTypename}_ClientImpl(IonClientContext context) : I{serviceTypename}
        {
            {MethodInfoDecls}

            {body}
        }
        """;

    private static readonly string ServiceClientMethodInfoDecl =
        """
            private static readonly Lazy<MethodInfo> {methodName}_Ref = new(() =>
                typeof(I{serviceTypename}).GetMethod(nameof({methodName}), BindingFlags.Public | BindingFlags.Instance)!);
        """;

    private static readonly string ServiceClientMethodDecl =
        """
            {compileGeneratedAttributes}
            public async Task<{methodReturnType}> {methodName}({args})
            {
                var req = new IonRequest(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);
            
                var writer = new CborWriter();
                
                const int argsSize = {argSize};
            
                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();
            
                return await req.CallAsync<{methodReturnType}>(writer.Encode());
            }
        """;

    private static readonly string ServiceClientMethodDeclNoReturn =
        """
            {compileGeneratedAttributes}
            public async Task {methodName}({args})
            {
                var req = new IonRequest(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);

                var writer = new CborWriter();
                
                const int argsSize = {argSize};

                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();

                await req.CallAsync(writer.Encode());
            }
        """;

    private static readonly string ServiceClientMethodDeclStream =
        """
            public IAsyncEnumerable<{methodReturnType}> {methodName}({args})
            {
                var ws = new IonWsClient(context, typeof(I{serviceTypename}), {methodName}_Ref.Value);
            
                var writer = new CborWriter();
        
                const int argsSize = {argSize};
                
                writer.WriteStartArray(argsSize);
                
                {argsWrite}
                
                writer.WriteEndArray();
            
                return ws.CallServerStreamingAsync<{methodReturnType}>(writer.Encode());
            }
        """;

    private string GenerateServiceClientImpl(IonService service)
    {
        var methodsBuilder = new StringBuilder();
        var methodInfoDecl = new StringBuilder();
        var serviceTypename = service.name.Identifier;
        var builder = ServiceClientImplTemplate;

        methodInfoDecl.AppendLine();
        methodsBuilder.AppendLine();

        foreach (var method in service.methods)
        {
            var methodName = method.name.Identifier;
            var argSize = method.arguments.Count;

            var writeArgsExpression = GenerateWriteArguments(method);

            var methodArgs = string.Join(", ", method.arguments.Select(GenerateClientMethodArgument));

            var template =
                method.IsStreamable ?
                    ServiceClientMethodDeclStream :
                        method.returnType.IsVoid
                        ? ServiceClientMethodDeclNoReturn
                        : ServiceClientMethodDecl;

            var templateMethod =
                template
                    .Replace("{serviceTypename}", serviceTypename)
                    .Replace("{methodName}", methodName)
                    .Replace("{argSize}", argSize.ToString())
                    .Replace("{argsWrite}", writeArgsExpression)
                    .Replace("{args}", methodArgs);

            if (!method.returnType.IsVoid)
                templateMethod = templateMethod
                    .Replace("{methodReturnType}", UnwrapType(method.returnType));

            methodsBuilder.AppendLine(templateMethod);


            var methodInfoDeclaration =
                ServiceClientMethodInfoDecl
                    .Replace("{methodName}", methodName)
                    .Replace("{serviceTypename}", serviceTypename);


            methodInfoDecl.AppendLine(methodInfoDeclaration);
        }

        return builder
            .Replace("{MethodInfoDecls}", methodInfoDecl.ToString())
            .Replace("{body}", methodsBuilder.ToString())
            .Replace("{serviceTypename}", serviceTypename);

        static string GenerateClientMethodArgument(IonArgument field) =>
            $"{UnwrapType(field.type)} __{field.name.Identifier}";
    }

    private string GenerateUnion(IonUnion union)
    {
        var builder = new StringBuilder();

        var unionInterface =
            Union_InterfaceBody
                .Replace("{unionName}", union.name.Identifier);


        builder.AppendLine();
        builder.AppendLine(unionInterface);


        var cases = GenerateUnionCase(union, out var targetTypesForFormatterGeneration);

        builder.AppendLine();
        builder.AppendLine(cases);

        builder.AppendLine();
        builder.AppendLine(GenerateUnionFormatterFraction(union));

        foreach (var ionType in targetTypesForFormatterGeneration)
        {
            //builder.AppendLine();
            //builder.AppendLine(GenerateMessage(ionType));
            builder.AppendLine();
            builder.AppendLine(GenerateFormatterForType(ionType));
        }

        return builder.ToString();
    }

    private string GenerateUnionCase(IonUnion union, out List<IonType> unionTypesRequiredFormatters)
    {
        unionTypesRequiredFormatters = new();
        var builder = new StringBuilder();
        var index = 0;
        foreach (var type in union.types)
        {
            if (!type.IsUnionCase)
            {
                index++;
                continue;
            }
            unionTypesRequiredFormatters.Add(type);

            var fields = string.Join(", ", type.fields.Select(f => $"public {GenerateField(f)}"));
            builder.AppendLine();
            builder.AppendLine(Union_CaseBody
                .Replace("{fields}", fields.ToString())
                .Replace("{caseTypeName}", type.name.Identifier)
                .Replace("{unionName}", union.name.Identifier)
                .Replace("{caseIndex}", index.ToString())
            );

            index++;
        }

        return builder.ToString();
    }

    private static readonly string Union_InterfaceBody =
        """
        export interface I{unionName} extends IIonUnion<I{unionName}>
        {
          UnionKey: string;
          UnionIndex: number;
        }
        """;
    private static readonly string Union_CaseBody =
        """
        export class {caseTypeName} implements I{unionName}
        {
          constructor({fields}) { }
        
          UnionKey: string = "{caseTypeName}";
          UnionIndex: number = {caseIndex};
        }
        """;

    private string GenerateUnionFormatterFraction(IonUnion union)
    {
        var builder = new StringBuilder();

        var writeChecks = new StringBuilder();
        var readChecks = new StringBuilder();
        var index = 0;
        foreach (var @case in union.types)
        {
            writeChecks.AppendLine(
                UnionWriteCheck
                    .Replace("{caseTypeName}", @case.name.Identifier)
                    .Replace("{caseIndex}", index.ToString())
            );
            readChecks.AppendLine(
                UnionReadCheck
                    .Replace("{caseTypeName}", @case.name.Identifier)
                    .Replace("{caseIndex}", index.ToString())
            );

            index++;
        }


        builder.AppendLine();
        builder.AppendLine(Union_InterfaceFormatter
            .Replace("{unionInterface}", union.name.Identifier)
            .Replace("{readCheks}", readChecks.ToString())
            .Replace("{writeChecks}", writeChecks.ToString())
        );

        return builder.ToString();
    }


    private static readonly string Union_InterfaceFormatter =
        """
        IonFormatterStorage.register("I{unionInterface}", {
          read(reader: CborReader): I{unionInterface} {
            reader.readStartArray();
            let value: I{unionInterface} = null as any;
            const unionIndex = reader.readUInt32();
            
            if (false)
            {}
            {readCheks}
            else throw new Error();
          
            reader.readEndArray();
            return value!;
          },
          write(writer: CborWriter, value: I{unionInterface}): void {
            writer.writeStartArray(null);
            writer.writeUInt32(value.UnionIndex);
            if (false)
            {}
            {writeChecks}  
            else throw new Error();
            writer.writeEndArray();
          }
        });
        """;

    private static readonly string UnionReadCheck =
        """
            else if (unionIndex == {caseIndex})
              value = IonFormatterStorage.get<{caseTypeName}>("{caseTypeName}").read(reader);
        """;

    private static readonly string UnionWriteCheck =
        """
            else if (value.UnionIndex == {caseIndex})
              IonFormatterStorage.get<{caseTypeName}>("{caseTypeName}").write(writer, value as {caseTypeName});
        """;
}
