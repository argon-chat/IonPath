namespace ion.compiler.CodeGen;

using Emitters;
using ion.runtime;
using ion.syntax;
using Templates;
using System.Text;

/// <summary>
/// Унифицированный C# генератор, наследующий от CodeGeneratorBase.
/// </summary>
public sealed class CSharpCodeGenerator : CodeGeneratorBase
{
    private static readonly string CompileGeneratedAttributes =
        "[GeneratedCodeAttribute(\"ionc\", null), CompilerGeneratedAttribute]";

    public CSharpCodeGenerator(string @namespace)
        : base(
            @namespace,
            new CSharpEmitter(),
            new CSharpTypeNameResolver(),
            new CSharpTemplateProvider())
    {
    }

    public bool UseMaybeWrapper
    {
        get => ((CSharpTypeNameResolver)TypeResolver).UseMaybeWrapper;
        set => ((CSharpTypeNameResolver)TypeResolver).UseMaybeWrapper = value;
    }

    public override void GenerateProjectFile(string projectName, FileInfo outputFile)
    {
    }

    public override string GenerateGlobalTypes() =>
        """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a code generation tool.
        //     Changes to this file may cause incorrect behavior and will be lost
        //     if the code is regenerated.
        //
        //     Generator: IonPath Codegen
        // </auto-generated>
        //------------------------------------------------------------------------------

        #pragma warning disable

        global using i1 = System.SByte;
        global using i2 = System.Int16;
        global using i4 = System.Int32;
        global using i8 = System.Int64;
        global using i16 = System.Int128;

        global using u1 = System.Byte;
        global using u2 = System.UInt16;
        global using u4 = System.UInt32;
        global using u8 = System.UInt64;
        global using u16 = System.UInt128;

        global using f2 = System.Half;
        global using f4 = System.Single;
        global using f8 = System.Double;
        global using guid = System.Guid;
        global using dateonly = System.DateOnly;
        global using timeonly = System.TimeOnly;
        global using duration = System.TimeSpan;
        global using datetime = System.DateTime;
        global using bytes = ion.runtime.IonBytes;

        global using System.CodeDom.Compiler;
        global using System.Runtime.CompilerServices;

        global using System.Formats.Cbor;
        global using ion.runtime;
        global using ion.runtime.network;
        global using Microsoft.Extensions.DependencyInjection;
        global using System.Diagnostics;
        global using System.Reflection;
        global using ion.runtime.client;
        global using System.Buffers;
        """;

    // ═══════════════════════════════════════════════════════════════════
    // MODULE INIT
    // ═══════════════════════════════════════════════════════════════════

    public override string GenerateModuleInit(
        IEnumerable<IonType> types,
        IReadOnlyList<IonService> services,
        bool clientToo,
        bool serverToo)
    {
        var candidates = types.Where(t => !t.IsBuiltin && !t.IsScalar && !t.IsVoid).ToArray();
        var sb = new StringBuilder();
        sb.AppendLine(FileHeader());

        var registrations = new StringBuilder();
        registrations.AppendLine();

        // Register formatters
        foreach (var t in candidates)
        {
            registrations.AppendLine(
                $"      IonFormatterStorage<{TypeResolver.Resolve(t)}>.Value = new Ion_{TypeResolver.Resolve(t)}_Formatter();");
        }

        // Register union case formatters
        foreach (var t in candidates.Where(x => x.IsUnion).OfType<IonUnion>()
                     .SelectMany(x => x.types).Where(x => x.IsUnionCase))
        {
            registrations.AppendLine(
                $"      IonFormatterStorage<{TypeResolver.Resolve(t)}>.Value = new Ion_{TypeResolver.Resolve(t)}_Formatter();");
        }

        // Register server executors
        if (serverToo)
        {
            foreach (var service in services)
            {
                var typeName = service.name.Identifier;
                registrations.AppendLine(
                    $"      IonExecutorMetadataStorage.AddExecutor<Ion_{typeName}_ServiceExecutor>(\"I{typeName}\");");
            }
        }

        // Register client impls
        if (clientToo)
        {
            foreach (var service in services)
            {
                var typeName = service.name.Identifier;
                registrations.AppendLine(
                    $"      IonExecutorMetadataStorage.AddClient<Ion_{typeName}_ClientImpl>(\"I{typeName}\");");
            }
        }

        var ctx = new TemplateContext()
            .Set("generatedAttr", CompileGeneratedAttributes)
            .Set("registrations", registrations.ToString());

        sb.AppendLine(ctx.Apply(Templates.ModuleInitTemplate));
        return PostProcess(sb.ToString());
    }

    // ═══════════════════════════════════════════════════════════════════
    // SERVICE EXECUTORS
    // ═══════════════════════════════════════════════════════════════════

    public override string GenerateAllServiceExecutors(IEnumerable<IonService> services)
    {
        var sb = new StringBuilder();
        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var service in services)
        {
            sb.AppendLine(GenerateServiceExecutor(service));
            sb.AppendLine();
        }

        return PostProcess(sb.ToString());
    }

    private string GenerateServiceExecutor(IonService service)
    {
        var serviceName = service.name.Identifier;

        // Determine interfaces
        var hasStream = service.methods.Any(m => m.IsStreamable);
        var hasUnary = service.methods.Any(m => !m.IsStreamable);
        var interfaces = (hasStream, hasUnary) switch
        {
            (true, true) => "IServiceExecutorRouter, IServiceStreamExecutorRouter",
            (true, false) => "IServiceStreamExecutorRouter",
            _ => "IServiceExecutorRouter"
        };

        var methodsBuilder = new StringBuilder();
        var unaryBranches = new StringBuilder();
        var streamBranches = new StringBuilder();

        foreach (var method in service.methods)
        {
            if (method.IsStreamable)
                GenerateStreamExecutorMethod(method, serviceName, methodsBuilder, streamBranches);
            else
                GenerateUnaryExecutorMethod(method, serviceName, methodsBuilder, unaryBranches);
        }

        // Build allowed stream methods
        var allowedStreamMethods = service.methods
            .Where(m => m.arguments.Any(a => a.mod == IonArgumentModifiers.Stream))
            .Select(m => $"\"{m.name.Identifier}\"");

        // Build routers
        var unaryRouter = hasUnary
            ? new TemplateContext()
                .Set("branches", unaryBranches.ToString())
                .Apply(Templates.ServiceExecutorRouterTemplate)
            : "";

        var streamRouter = hasStream
            ? new TemplateContext()
                .Set("branches", streamBranches.ToString())
                .Apply(Templates.ServiceExecutorStreamRouterTemplate)
            : "";

        var ctx = new TemplateContext()
            .Set("serviceName", serviceName)
            .Set("interfaces", interfaces)
            .Set("methods", methodsBuilder.ToString())
            .Set("routerBody", unaryRouter)
            .Set("streamRouterBody", streamRouter)
            .Set("allowedStreamMethods", string.Join(", ", allowedStreamMethods));

        return ctx.Apply(Templates.ServiceExecutorClassTemplate);
    }

    private void GenerateUnaryExecutorMethod(
        IonMethod method,
        string serviceName,
        StringBuilder methodsBuilder,
        StringBuilder branchBuilder)
    {
        var methodName = method.name.Identifier;
        var argsCount = method.arguments.Count(a => a.mod != IonArgumentModifiers.Stream);

        var readArgs = string.Join($"\n{Emitter.Indent(2)}",
            method.arguments.Where(a => a.mod != IonArgumentModifiers.Stream).Select(GenerateReadArgument));

        var captureArgs = GenerateCaptureArgs(method, "ct");

        var template = method.returnType.IsVoid
            ? Templates.ServiceExecutorMethodVoidTemplate
            : Templates.ServiceExecutorMethodTemplate;

        var ctx = new TemplateContext()
            .Set("generatedAttr", CompileGeneratedAttributes)
            .Set("serviceName", serviceName)
            .Set("methodName", methodName)
            .Set("argsCount", argsCount.ToString())
            .Set("readArgs", readArgs)
            .Set("captureArgs", captureArgs);

        if (!method.returnType.IsVoid)
            ctx.Set("writeResult", GenerateWriteReturnValue(method.returnType));

        methodsBuilder.AppendLine(ctx.Apply(template));

        // Branch
        var branchCtx = new TemplateContext()
            .Set("methodName", methodName)
            .Set("executorArgs", "writer, ct");
        branchBuilder.AppendLine(branchCtx.Apply(Templates.ServiceExecutorBranchTemplate));
    }

    private void GenerateStreamExecutorMethod(
        IonMethod method,
        string serviceName,
        StringBuilder methodsBuilder,
        StringBuilder branchBuilder)
    {
        var methodName = method.name.Identifier;
        var argsCount = method.arguments.Count(a => a.mod != IonArgumentModifiers.Stream);

        var readArgs = string.Join($"\n{Emitter.Indent(2)}",
            method.arguments.Where(a => a.mod != IonArgumentModifiers.Stream).Select(GenerateReadArgument));

        var captureArgs = GenerateCaptureArgs(method, "ct");

        // Input stream cast
        var inputStreamArg = method.arguments.FirstOrDefault(a => a.mod == IonArgumentModifiers.Stream);
        var inputStreamCast = "";
        if (inputStreamArg != null && Templates.InputStreamCastTemplate != null)
        {
            inputStreamCast = new TemplateContext()
                .Set("inputStreamType", TypeResolver.Resolve(inputStreamArg.type))
                .Apply(Templates.InputStreamCastTemplate);
        }

        var ctx = new TemplateContext()
            .Set("serviceName", serviceName)
            .Set("methodName", methodName)
            .Set("argsCount", argsCount.ToString())
            .Set("readArgs", readArgs)
            .Set("captureArgs", captureArgs)
            .Set("returnType", TypeResolver.Resolve(method.returnType))
            .Set("inputStreamCast", inputStreamCast);

        methodsBuilder.AppendLine(ctx.Apply(Templates.ServiceExecutorMethodStreamTemplate));

        // Branch
        var branchCtx = new TemplateContext()
            .Set("methodName", methodName)
            .Set("executorArgs", "inputStream, ct");
        branchBuilder.AppendLine(branchCtx.Apply(Templates.ServiceExecutorBranchTemplate));
    }

    // ═══════════════════════════════════════════════════════════════════
    // SERVICE CLIENT IMPL
    // ═══════════════════════════════════════════════════════════════════

    public override string GenerateAllServiceClientImpl(IEnumerable<IonService> services)
    {
        var sb = new StringBuilder();
        sb.AppendLine(FileHeader());
        sb.AppendLine();

        foreach (var service in services)
        {
            sb.AppendLine(GenerateServiceClientImpl(service));
            sb.AppendLine();
        }

        return PostProcess(sb.ToString());
    }

    private string GenerateServiceClientImpl(IonService service)
    {
        var serviceName = service.name.Identifier;
        var methodsBuilder = new StringBuilder();
        var methodInfoDecls = new StringBuilder();

        foreach (var method in service.methods)
        {
            var methodName = method.name.Identifier;
            var argsCount = method.arguments.Count(a => a.mod != IonArgumentModifiers.Stream);

            // Method info declaration
            methodInfoDecls.AppendLine($"""
                    private static readonly Lazy<MethodInfo> {methodName}_Ref = new(() =>
                        typeof(I{serviceName}).GetMethod(nameof({methodName}), BindingFlags.Public | BindingFlags.Instance)!);
                """);

            // Write args
            var writeArgs = string.Join($"\n{Emitter.Indent(2)}",
                method.arguments.Where(a => a.mod != IonArgumentModifiers.Stream).Select(GenerateWriteArgument));

            // Method args
            var methodArgs = string.Join(", ",
                method.arguments.Select(a => GenerateClientMethodArg(a))
                    .Concat(["CancellationToken ct = default"]));

            // Select template
            var template = method.IsStreamable
                ? Templates.ServiceClientMethodStreamTemplate
                : method.returnType.IsVoid
                    ? Templates.ServiceClientMethodVoidTemplate
                    : method.returnType.IsArray && Templates.ServiceClientMethodArrayTemplate != null
                        ? Templates.ServiceClientMethodArrayTemplate
                        : method.returnType.IsMaybe && Templates.ServiceClientMethodNullableTemplate != null
                            ? Templates.ServiceClientMethodNullableTemplate
                            : Templates.ServiceClientMethodTemplate;

            // Stream call
            var inputStreamArg = method.arguments.FirstOrDefault(a => a.mod == IonArgumentModifiers.Stream);
            var streamCall = inputStreamArg != null
                ? $"ws.CallServerStreamingAsync<{TypeResolver.Resolve(method.returnType)}, {TypeResolver.Resolve(inputStreamArg.type)}>(writer.Encode(), inputStream, ct: ct)"
                : $"ws.CallServerStreamingAsync<{TypeResolver.Resolve(method.returnType)}>(writer.Encode(), ct: ct)";

            var ctx = new TemplateContext()
                .Set("generatedAttr", CompileGeneratedAttributes)
                .Set("serviceName", serviceName)
                .Set("methodName", methodName)
                .Set("argsCount", argsCount.ToString())
                .Set("writeArgs", writeArgs)
                .Set("args", methodArgs)
                .Set("streamCall", streamCall);

            if (!method.returnType.IsVoid)
            {
                ctx.Set("returnType", TypeResolver.Resolve(method.returnType));
                if (method.returnType is IonGenericType gt)
                    ctx.Set("returnTypeUnwrapped", TypeResolver.Resolve(gt.TypeArguments[0]));
            }

            methodsBuilder.AppendLine(ctx.Apply(template));
        }

        var classCtx = new TemplateContext()
            .Set("generatedAttr", CompileGeneratedAttributes)
            .Set("serviceName", serviceName)
            .Set("methods", methodsBuilder.ToString())
            .Set("methodInfoDecls", methodInfoDecls.ToString());

        return classCtx.Apply(Templates.ServiceClientClassTemplate);
    }

    private string GenerateClientMethodArg(IonArgument arg)
    {
        if (arg.mod == IonArgumentModifiers.Stream)
            return $"IAsyncEnumerable<{TypeResolver.Resolve(arg.type)}> inputStream";
        return $"{TypeResolver.Resolve(arg.type)} {FormatLocalVariableName(arg.name.Identifier)}";
    }

    // ═══════════════════════════════════════════════════════════════════
    // FORMATTER GENERATION
    // ═══════════════════════════════════════════════════════════════════

    protected override string GenerateEnumFormatter(IonEnum e)
    {
        var ctx = new TemplateContext()
            .Set("generatedAttr", CompileGeneratedAttributes)
            .Set("typeName", e.name.Identifier)
            .Set("baseTypeName", e.baseType.name.Identifier)
            .Set("readExpr", TypeResolver.ResolveFormatterRef(e.baseType))
            .Set("writeExpr", $"{TypeResolver.ResolveFormatterRef(e.baseType)}.Write(writer, casted);");

        return ctx.Apply(Templates.FormatterEnumTemplate);
    }

    protected override string GenerateFlagsFormatter(IonFlags f)
    {
        var ctx = new TemplateContext()
            .Set("generatedAttr", CompileGeneratedAttributes)
            .Set("typeName", f.name.Identifier)
            .Set("baseTypeName", f.baseType.name.Identifier)
            .Set("readExpr", TypeResolver.ResolveFormatterRef(f.baseType))
            .Set("writeExpr", $"{TypeResolver.ResolveFormatterRef(f.baseType)}.Write(writer, casted);");

        return ctx.Apply(Templates.FormatterFlagsTemplate);
    }

    protected override string GenerateMessageFormatter(IonType type, bool isUnionCase)
    {
        var readFields = string.Join($"\n{Emitter.Indent(2)}",
            type.fields.Select(GenerateReadField));
        var writeFields = string.Join($"\n{Emitter.Indent(2)}",
            type.fields.Select(f => GenerateWriteField(f, "value.")));
        var ctorArgs = GenerateCaptureFields(type);

        var template = isUnionCase ? Templates.FormatterUnionCaseTemplate : Templates.FormatterTemplate;

        var ctx = new TemplateContext()
            .Set("generatedAttr", CompileGeneratedAttributes)
            .Set("typeName", type.name.Identifier)
            .Set("readFields", readFields)
            .Set("writeFields", writeFields)
            .Set("ctorArgs", ctorArgs)
            .Set("fieldsCount", type.fields.Count.ToString());

        return ctx.Apply(template);
    }

    protected override string GenerateUnionFormatter(IonUnion union)
    {
        var readCases = new StringBuilder();
        var writeCases = new StringBuilder();
        var index = 0;

        foreach (var caseType in union.types)
        {
            var caseCtx = new TemplateContext()
                .Set("caseIndex", index.ToString())
                .Set("caseTypeName", caseType.name.Identifier);

            readCases.AppendLine(caseCtx.Apply(Templates.FormatterUnionReadCaseTemplate));
            writeCases.AppendLine(caseCtx.Apply(Templates.FormatterUnionWriteCaseTemplate));
            index++;
        }

        var ctx = new TemplateContext()
            .Set("generatedAttr", CompileGeneratedAttributes)
            .Set("unionName", union.name.Identifier)
            .Set("readCases", readCases.ToString())
            .Set("writeCases", writeCases.ToString());

        return ctx.Apply(Templates.FormatterUnionTemplate);
    }

    // ═══════════════════════════════════════════════════════════════════
    // FIELD READ/WRITE
    // ═══════════════════════════════════════════════════════════════════

    protected override string GenerateReadField(IonField field)
    {
        var varName = FormatLocalVariableName(field.name.Identifier);

        return field.type switch
        {
            { IsArray: true } when field.type is IonGenericType gt =>
                $"var {varName} = IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.ReadArray(reader);",
            { IsMaybe: true } when field.type is IonGenericType gt =>
                UseMaybeWrapper
                    ? $"var {varName} = IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.ReadMaybe(reader);"
                    : $"var {varName} = reader.ReadNullable<{TypeResolver.Resolve(gt.TypeArguments[0])}>();",
            { IsPartial: true } => "", // TODO
            _ => $"var {varName} = {TypeResolver.ResolveFormatterRef(field.type)}.Read(reader);"
        };
    }

    protected override string GenerateWriteField(IonField field, string valuePrefix)
    {
        var fieldAccess = $"{valuePrefix}{field.name.Identifier}";

        return field.type switch
        {
            { IsArray: true } when field.type is IonGenericType gt =>
                $"IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.WriteArray(writer, {fieldAccess});",
            { IsMaybe: true } when field.type is IonGenericType gt =>
                UseMaybeWrapper
                    ? $"IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.WriteMaybe(writer, {fieldAccess});"
                    : $"IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.WriteNullable(writer, {fieldAccess});",
            _ => $"{TypeResolver.ResolveFormatterRef(field.type)}.Write(writer, {fieldAccess});"
        };
    }

    protected override string GenerateReadArgument(IonArgument arg)
    {
        var varName = FormatLocalVariableName(arg.name.Identifier);

        return arg.type switch
        {
            { IsArray: true } when arg.type is IonGenericType gt =>
                $"var {varName} = IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.ReadArray(reader);",
            { IsMaybe: true } when arg.type is IonGenericType gt =>
                UseMaybeWrapper
                    ? $"var {varName} = IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.ReadMaybe(reader);"
                    : $"var {varName} = reader.ReadNullable<{TypeResolver.Resolve(gt.TypeArguments[0])}>();",
            _ => $"var {varName} = {TypeResolver.ResolveFormatterRef(arg.type)}.Read(reader);"
        };
    }

    protected override string GenerateWriteArgument(IonArgument arg)
    {
        var varName = FormatLocalVariableName(arg.name.Identifier);

        return arg.type switch
        {
            { IsArray: true } when arg.type is IonGenericType gt =>
                $"IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.WriteArray(writer, {varName});",
            { IsMaybe: true } when arg.type is IonGenericType gt =>
                UseMaybeWrapper
                    ? $"IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.WriteMaybe(writer, {varName});"
                    : $"IonFormatterStorage<{TypeResolver.Resolve(gt.TypeArguments[0])}>.WriteNullable(writer, {varName});",
            _ => $"{TypeResolver.ResolveFormatterRef(arg.type)}.Write(writer, {varName});"
        };
    }

    private string GenerateWriteReturnValue(IonType returnType)
    {
        return returnType switch
        {
            { IsArray: true } when returnType is IonGenericType gt =>
                $"{TypeResolver.ResolveFormatterRef(gt.TypeArguments[0])}.WriteArray(writer, result);",
            { IsMaybe: true } when returnType is IonGenericType gt =>
                UseMaybeWrapper
                    ? $"{TypeResolver.ResolveFormatterRef(gt.TypeArguments[0])}.WriteMaybe(writer, result);"
                    : $"{TypeResolver.ResolveFormatterRef(gt.TypeArguments[0])}.WriteNullable(writer, result);",
            _ => $"{TypeResolver.ResolveFormatterRef(returnType)}.Write(writer, result);"
        };
    }

    // ═══════════════════════════════════════════════════════════════════
    // HELPERS
    // ═══════════════════════════════════════════════════════════════════

    protected override string FormatLocalVariableName(string name)
        => $"__{name.ToLowerInvariant()}";

    protected override string PostProcess(string code)
        => code.Replace("{compileGeneratedAttributes}", CompileGeneratedAttributes)
               .Replace("{generatedAttr}", CompileGeneratedAttributes);
}
