namespace ion.compiler.CodeGen.Emitters;

using System.Text;

/// <summary>
/// TypeScript реализация ICodeEmitter.
/// Генерирует синтаксические конструкции TypeScript.
/// </summary>
public sealed class TypeScriptEmitter : ICodeEmitter
{
    public string Language => "TypeScript";
    public string FileExtension => ".ts";
    public string GeneratedCodeAttribute => ""; // TS не имеет атрибутов генерации

    private const string AutoGeneratedHeader =
        """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a code generation tool.
        //     Changes to this file may cause incorrect behavior and will be lost
        //     if the code is regenerated.
        //
        //     Generator: IonPath Codegen
        // </auto-generated>
        //------------------------------------------------------------------------------
        """;

    public string FileHeader(string? @namespace = null)
    {
        // TypeScript doesn't use namespaces in the same way
        return AutoGeneratedHeader;
    }

    public string WrapInNamespace(string @namespace, string content)
    {
        // TypeScript uses modules, not namespaces typically
        return content;
    }

    // ═══════════════════════════════════════════════════════════════════
    // TYPE DECLARATIONS
    // ═══════════════════════════════════════════════════════════════════

    public string EnumDeclaration(string name, IEnumerable<EnumMember> members, EnumOptions? options = null)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"export enum {name}");
        sb.AppendLine("{");
        foreach (var m in members)
            sb.AppendLine($"  {m.Name} = {m.Value},");
        sb.AppendLine("}");
        return sb.ToString();
    }

    public string FlagsDeclaration(string name, string? baseType, IEnumerable<EnumMember> members)
    {
        // TypeScript doesn't have a special flags enum, same as regular enum
        return EnumDeclaration(name, members);
    }

    public string MessageDeclaration(string name, IEnumerable<FieldDecl> fields)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"export interface {name} {{");
        foreach (var f in fields)
        {
            var optional = f.IsOptional ? "?" : "";
            sb.AppendLine($"  {f.Name}{optional}: {f.Type};");
        }
        sb.AppendLine("};");
        return sb.ToString();
    }

    public string TypedefDeclaration(string name, string underlyingType)
    {
        return $"export type {name} = {underlyingType};";
    }

    public string ServiceInterfaceDeclaration(string name, IEnumerable<MethodDecl> methods, string? baseInterface = null)
    {
        var sb = new StringBuilder();
        var extends = baseInterface != null ? $" extends {baseInterface}" : "";
        sb.AppendLine($"export interface {name}{extends}");
        sb.AppendLine("{");

        foreach (var method in methods)
        {
            var parameters = method.Parameters.Select(FormatParameter);
            sb.AppendLine($"  {method.Name}({string.Join(", ", parameters)}): {method.ReturnType};");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    public string ClassDeclaration(ClassDecl decl)
    {
        var sb = new StringBuilder();

        var exportStr = decl.Modifiers.HasFlag(ClassModifiers.Export) ? "export " : "";
        var abstractStr = decl.Modifiers.HasFlag(ClassModifiers.Abstract) ? "abstract " : "";

        var extends = decl.Extends != null ? $" extends {decl.Extends}" : "";
        var implements = decl.Implements?.Any() == true
            ? $" implements {string.Join(", ", decl.Implements)}"
            : "";

        sb.AppendLine($"{exportStr}{abstractStr}class {decl.Name}{extends}{implements}");
        sb.AppendLine("{");

        // Constructor with fields
        if (decl.ConstructorParams?.Any() == true)
        {
            var ctorParams = string.Join(", ", decl.ConstructorParams.Select(p =>
                $"public {p.Name}: {p.Type}"));
            sb.AppendLine($"  constructor({ctorParams}) {{");
            if (!string.IsNullOrEmpty(decl.Extends))
                sb.AppendLine("    super();");
            sb.AppendLine("  }");
        }

        // Additional fields
        if (decl.Fields != null)
        {
            foreach (var field in decl.Fields)
                sb.AppendLine($"  {field.Name}: {field.Type};");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    // ═══════════════════════════════════════════════════════════════════
    // UNION TYPES
    // ═══════════════════════════════════════════════════════════════════

    public string UnionBaseDeclaration(string name, IEnumerable<string> caseNames, IEnumerable<FieldDecl>? sharedFields = null)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"export abstract class I{name} implements IIonUnion<I{name}>");
        sb.AppendLine("{");
        sb.AppendLine("  abstract UnionKey: string;");
        sb.AppendLine("  abstract UnionIndex: number;");
        sb.AppendLine();

        // Shared fields
        if (sharedFields != null)
        {
            foreach (var field in sharedFields)
                sb.AppendLine($"  abstract {field.Name}: {field.Type};");
            sb.AppendLine();
        }

        // Type guard methods
        foreach (var caseName in caseNames)
        {
            sb.AppendLine($"  public is{caseName}(): this is {caseName} " + "{");
            sb.AppendLine($"    return this.UnionKey === \"{caseName}\";");
            sb.AppendLine("  }");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    public string UnionCaseDeclaration(string caseName, string unionName, int caseIndex, IEnumerable<FieldDecl> fields)
    {
        var fieldsList = fields.ToList();
        var ctorParams = string.Join(", ", fieldsList.Select(f => $"public {f.Name}: {f.Type}"));

        var sb = new StringBuilder();
        sb.AppendLine($"export class {caseName} extends I{unionName}");
        sb.AppendLine("{");
        sb.AppendLine($"  constructor({ctorParams}) " + "{ super(); }");
        sb.AppendLine();
        sb.AppendLine($"  UnionKey: string = \"{caseName}\";");
        sb.AppendLine($"  UnionIndex: number = {caseIndex};");
        sb.AppendLine("}");
        return sb.ToString();
    }

    // ═══════════════════════════════════════════════════════════════════
    // TYPE NAMES
    // ═══════════════════════════════════════════════════════════════════

    public string NullableType(string innerType) => $"{innerType} | null";

    public string ArrayType(string innerType) => $"IonArray<{innerType}>";

    public string GenericType(string baseName, IEnumerable<string> typeArgs)
        => $"{baseName}<{string.Join(", ", typeArgs)}>";

    public string AsyncReturnType(string? innerType)
        => innerType == null ? "Promise<void>" : $"Promise<{innerType}>";

    public string StreamReturnType(string innerType)
        => $"AsyncIterable<{innerType}>";

    public string StreamInputType(string innerType)
        => $"AsyncIterable<{innerType}>";

    // ═══════════════════════════════════════════════════════════════════
    // FORMATTING HELPERS
    // ═══════════════════════════════════════════════════════════════════

    public string Indent(int level) => new(' ', level * 2);

    public string FormatIdentifier(string name)
    {
        // TypeScript reserved words
        var keywords = new HashSet<string>
        {
            "break", "case", "catch", "class", "const", "continue", "debugger",
            "default", "delete", "do", "else", "enum", "export", "extends",
            "false", "finally", "for", "function", "if", "import", "in",
            "instanceof", "new", "null", "return", "super", "switch", "this",
            "throw", "true", "try", "typeof", "var", "void", "while", "with",
            "as", "implements", "interface", "let", "package", "private",
            "protected", "public", "static", "yield", "any", "boolean",
            "number", "string", "symbol", "type", "from", "of"
        };

        return keywords.Contains(name) ? $"_{name}" : name;
    }

    public string FormatEnumValue(string value, int? bits = null)
    {
        // For large integers (56+ bits), use bigint notation
        if (bits is >= 56)
            return $"{value}n as any";

        // Check if value itself suggests bigint
        if (long.TryParse(value, out var longVal) && longVal is > int.MaxValue or < int.MinValue)
            return $"{value}n as any";

        return value;
    }

    private string FormatParameter(ParameterDecl p)
    {
        return $"{p.Name}: {p.Type}";
    }
}
