namespace ion.compiler.CodeGen.Emitters;

using System.Text;

/// <summary>
/// Go реализация ICodeEmitter.
/// Генерирует синтаксические конструкции Go.
/// </summary>
public sealed class GoEmitter : ICodeEmitter
{
    public string Language => "Go";
    public string FileExtension => ".go";
    public string GeneratedCodeAttribute => ""; // Go uses comments for generated code

    private const string AutoGeneratedHeader =
        """
        // Code generated by ionc. DO NOT EDIT.
        // source: ion protocol definition
        """;

    public string FileHeader(string? @namespace = null)
    {
        var sb = new StringBuilder();
        sb.AppendLine(AutoGeneratedHeader);
        sb.AppendLine();

        if (!string.IsNullOrEmpty(@namespace))
        {
            // Convert namespace to Go package name (lowercase, no dots)
            var packageName = @namespace.ToLowerInvariant().Replace(".", "").Replace("-", "");
            sb.AppendLine($"package {packageName}");
        }

        return sb.ToString();
    }

    public string WrapInNamespace(string @namespace, string content)
    {
        // Go uses package declaration at the top, not wrapping
        return content;
    }

    // ═══════════════════════════════════════════════════════════════════
    // TYPE DECLARATIONS
    // ═══════════════════════════════════════════════════════════════════

    public string EnumDeclaration(string name, IEnumerable<EnumMember> members, EnumOptions? options = null)
    {
        var sb = new StringBuilder();
        var baseType = options?.BaseType ?? "int32";

        // Type declaration
        sb.AppendLine($"// {name} represents an enumeration.");
        sb.AppendLine($"type {name} {baseType}");
        sb.AppendLine();

        // Constants
        sb.AppendLine("const (");
        foreach (var m in members)
        {
            sb.AppendLine($"\t{name}_{m.Name} {name} = {m.Value}");
        }
        sb.AppendLine(")");

        return sb.ToString();
    }

    public string FlagsDeclaration(string name, string? baseType, IEnumerable<EnumMember> members)
    {
        // Go doesn't have a special flags type, same as enum
        return EnumDeclaration(name, members, new EnumOptions(baseType ?? "uint32", IsFlags: true));
    }

    public string MessageDeclaration(string name, IEnumerable<FieldDecl> fields)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// {name} represents a message type.");
        sb.AppendLine($"type {name} struct " + "{");

        foreach (var f in fields)
        {
            // Go uses PascalCase for exported fields
            var fieldName = Capitalize(f.Name);
            sb.AppendLine($"\t{fieldName} {f.Type}");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    public string TypedefDeclaration(string name, string underlyingType)
    {
        return $"// {name} is a type alias.\ntype {name} = {underlyingType}";
    }

    public string ServiceInterfaceDeclaration(string name, IEnumerable<MethodDecl> methods, string? baseInterface = null)
    {
        var sb = new StringBuilder();
        sb.AppendLine($"// {name} defines the service interface.");
        sb.AppendLine($"type {name} interface " + "{");

        if (!string.IsNullOrEmpty(baseInterface))
        {
            sb.AppendLine($"\t{baseInterface}");
        }

        foreach (var method in methods)
        {
            var parameters = method.Parameters.Select(p => $"{p.Name} {p.Type}");
            // ctx should be first in Go convention
            var allParams = new[] { "ctx context.Context" }.Concat(parameters);

            // ReturnType already comes formatted from AsyncReturnType/StreamReturnType
            // Don't wrap again - just use it directly
            var returnType = method.ReturnType;
            if (string.IsNullOrEmpty(returnType))
                returnType = "error";

            sb.AppendLine($"\t{method.Name}({string.Join(", ", allParams)}) {returnType}");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    public string ClassDeclaration(ClassDecl decl)
    {
        // Go doesn't have classes, use struct + methods
        var sb = new StringBuilder();
        sb.AppendLine($"// {decl.Name} implementation.");
        sb.AppendLine($"type {decl.Name} struct " + "{");

        if (decl.Fields != null)
        {
            foreach (var field in decl.Fields)
            {
                sb.AppendLine($"\t{Capitalize(field.Name)} {field.Type}");
            }
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    // ═══════════════════════════════════════════════════════════════════
    // UNION TYPES
    // ═══════════════════════════════════════════════════════════════════

    public string UnionBaseDeclaration(string name, IEnumerable<string> caseNames, IEnumerable<FieldDecl>? sharedFields = null)
    {
        var sb = new StringBuilder();

        // Interface for the union
        sb.AppendLine($"// I{name} is the union interface.");
        sb.AppendLine($"type I{name} interface " + "{");
        sb.AppendLine("\tionUnionMarker()");
        sb.AppendLine("\tUnionKey() string");
        sb.AppendLine("\tUnionIndex() uint32");
        sb.AppendLine("}");

        return sb.ToString();
    }

    public string UnionCaseDeclaration(string caseName, string unionName, int caseIndex, IEnumerable<FieldDecl> fields)
    {
        var sb = new StringBuilder();

        // Struct for the case
        sb.AppendLine($"// {caseName} is a union case of I{unionName}.");
        sb.AppendLine($"type {caseName} struct " + "{");
        foreach (var f in fields)
        {
            sb.AppendLine($"\t{Capitalize(f.Name)} {f.Type}");
        }
        sb.AppendLine("}");
        sb.AppendLine();

        // Interface implementation methods
        sb.AppendLine($"func ({caseName}) ionUnionMarker() " + "{}");
        sb.AppendLine($"func ({caseName}) UnionKey() string " + "{ return \"" + caseName + "\" }");
        sb.AppendLine($"func ({caseName}) UnionIndex() uint32 " + "{ return " + caseIndex + " }");

        return sb.ToString();
    }

    // ═══════════════════════════════════════════════════════════════════
    // TYPE NAMES
    // ═══════════════════════════════════════════════════════════════════

    public string NullableType(string innerType) => $"*{innerType}";

    public string ArrayType(string innerType) => $"[]{innerType}";

    public string GenericType(string baseName, IEnumerable<string> typeArgs)
        => $"{baseName}[{string.Join(", ", typeArgs)}]";

    public string AsyncReturnType(string? innerType)
    {
        // Go uses (result, error) pattern
        if (string.IsNullOrEmpty(innerType) || innerType == "void")
            return "error";
        return $"({innerType}, error)";
    }

    public string StreamReturnType(string innerType)
        => $"<-chan {innerType}";

    public string StreamInputType(string innerType)
        => $"<-chan {innerType}";

    // ═══════════════════════════════════════════════════════════════════
    // FORMATTING HELPERS
    // ═══════════════════════════════════════════════════════════════════

    public string Indent(int level) => new('\t', level);

    public string FormatIdentifier(string name)
    {
        // Go reserved words
        var keywords = new HashSet<string>
        {
            "break", "case", "chan", "const", "continue", "default", "defer",
            "else", "fallthrough", "for", "func", "go", "goto", "if", "import",
            "interface", "map", "package", "range", "return", "select", "struct",
            "switch", "type", "var"
        };

        return keywords.Contains(name) ? $"{name}_" : name;
    }

    public string FormatEnumValue(string value, int? bits = null)
    {
        // Go doesn't need special formatting
        return value;
    }

    private static string Capitalize(string input)
    {
        if (string.IsNullOrEmpty(input)) return input;
        return char.ToUpperInvariant(input[0]) + input[1..];
    }
}
