namespace ion.compiler.CodeGen.Emitters;

using System.Text;

/// <summary>
/// C# реализация ICodeEmitter.
/// Генерирует синтаксические конструкции C#.
/// </summary>
public sealed class CSharpEmitter : ICodeEmitter
{
    public string Language => "CSharp";
    public string FileExtension => ".cs";
    public string GeneratedCodeAttribute => "[GeneratedCodeAttribute(\"ionc\", null), CompilerGeneratedAttribute]";

    private const string AutoGeneratedHeader =
        """
        //------------------------------------------------------------------------------
        // <auto-generated>
        //     This code was generated by a code generation tool.
        //     Changes to this file may cause incorrect behavior and will be lost
        //     if the code is regenerated.
        //
        //     Generator: IonPath Codegen
        // </auto-generated>
        //------------------------------------------------------------------------------

        #pragma warning disable
        #nullable enable
        """;

    public string FileHeader(string? @namespace = null)
    {
        if (string.IsNullOrEmpty(@namespace))
            return AutoGeneratedHeader;

        return $"""
                {AutoGeneratedHeader}


                namespace {@namespace};
                """;
    }

    public string WrapInNamespace(string @namespace, string content)
    {
        return $"""
                namespace {@namespace};

                {content}
                """;
    }

    // ???????????????????????????????????????????????????????????????????
    // TYPE DECLARATIONS
    // ???????????????????????????????????????????????????????????????????

    public string EnumDeclaration(string name, IEnumerable<EnumMember> members, EnumOptions? options = null)
    {
        var sb = new StringBuilder();
        sb.AppendLine(GeneratedCodeAttribute);

        if (options?.IsFlags == true)
            sb.AppendLine("[Flags]");

        if (options?.BaseType != null)
            sb.AppendLine($"public enum {name} : {options.BaseType}");
        else
            sb.AppendLine($"public enum {name}");

        sb.AppendLine("{");
        foreach (var m in members)
            sb.AppendLine($"    {m.Name} = {m.Value},");
        sb.AppendLine("}");

        return sb.ToString();
    }

    public string FlagsDeclaration(string name, string? baseType, IEnumerable<EnumMember> members)
    {
        return EnumDeclaration(name, members, new EnumOptions(baseType, IsFlags: true));
    }

    public string MessageDeclaration(string name, IEnumerable<FieldDecl> fields)
    {
        var fieldsList = fields.ToList();
        var sb = new StringBuilder();
        sb.AppendLine(GeneratedCodeAttribute);
        sb.Append($"public sealed record {name}(");
        sb.Append(string.Join(", ", fieldsList.Select(f => $"{f.Type} {f.Name}")));
        sb.AppendLine(");");
        return sb.ToString();
    }

    public string TypedefDeclaration(string name, string underlyingType)
    {
        return $"""
                {GeneratedCodeAttribute}
                public readonly record struct {name}({underlyingType} Value);
                """;
    }

    public string ServiceInterfaceDeclaration(string name, IEnumerable<MethodDecl> methods, string? baseInterface = null)
    {
        var sb = new StringBuilder();
        sb.AppendLine(GeneratedCodeAttribute);

        var extends = baseInterface != null ? $" : {baseInterface}" : "";
        sb.AppendLine($"public interface {name}{extends}");
        sb.AppendLine("{");

        foreach (var method in methods)
        {
            // Attributes
            if (method.Attributes != null)
            {
                foreach (var attr in method.Attributes)
                    sb.AppendLine($"    [{attr}]");
            }

            // Method signature
            var parameters = method.Parameters
                .Select(p => FormatParameter(p))
                .Concat(["CancellationToken ct = default"]);

            sb.AppendLine($"    {method.ReturnType} {method.Name}({string.Join(", ", parameters)});");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    public string ClassDeclaration(ClassDecl decl)
    {
        var sb = new StringBuilder();
        sb.AppendLine(GeneratedCodeAttribute);

        var modifiers = "public";
        if (decl.Modifiers.HasFlag(ClassModifiers.Sealed))
            modifiers += " sealed";
        if (decl.Modifiers.HasFlag(ClassModifiers.Abstract))
            modifiers += " abstract";

        var extends = decl.Extends != null ? $" : {decl.Extends}" : "";
        var implements = decl.Implements?.Any() == true
            ? (string.IsNullOrEmpty(extends) ? " : " : ", ") + string.Join(", ", decl.Implements)
            : "";

        var ctorParams = decl.ConstructorParams != null
            ? $"({string.Join(", ", decl.ConstructorParams.Select(p => $"{p.Type} {p.Name}"))})"
            : "";

        sb.AppendLine($"{modifiers} class {decl.Name}{ctorParams}{extends}{implements}");
        sb.AppendLine("{");

        // Fields
        if (decl.Fields != null)
        {
            foreach (var field in decl.Fields)
                sb.AppendLine($"    public {field.Type} {field.Name} {{ get; set; }}");
        }

        // Methods
        if (decl.Methods != null)
        {
            foreach (var method in decl.Methods)
                sb.AppendLine($"    // Method: {method.Name}");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    // ???????????????????????????????????????????????????????????????????
    // UNION TYPES
    // ???????????????????????????????????????????????????????????????????

    public string UnionBaseDeclaration(string name, IEnumerable<string> caseNames, IEnumerable<FieldDecl>? sharedFields = null)
    {
        var sb = new StringBuilder();
        sb.AppendLine(GeneratedCodeAttribute);
        sb.AppendLine($"public interface I{name} : IIonUnion<I{name}>");
        sb.AppendLine("{");
        sb.AppendLine("    string UnionKey { get; }");
        sb.AppendLine("    uint UnionIndex { get; }");
        sb.AppendLine();

        // Check properties
        foreach (var caseName in caseNames)
        {
            sb.AppendLine($"    internal bool Is{caseName} => this is {caseName};");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    public string UnionCaseDeclaration(string caseName, string unionName, int caseIndex, IEnumerable<FieldDecl> fields)
    {
        var fieldsList = fields.ToList();
        var fieldsStr = string.Join(", ", fieldsList.Select(f => $"{f.Type} {f.Name}"));

        var sb = new StringBuilder();
        sb.AppendLine(GeneratedCodeAttribute);
        sb.AppendLine($"public sealed record {caseName}({fieldsStr}) : I{unionName}");
        sb.AppendLine("{");
        sb.AppendLine($"    public string UnionKey => nameof({caseName});");
        sb.AppendLine($"    public uint UnionIndex => {caseIndex};");
        sb.AppendLine("}");
        return sb.ToString();
    }

    // ???????????????????????????????????????????????????????????????????
    // TYPE NAMES
    // ???????????????????????????????????????????????????????????????????

    public string NullableType(string innerType) => $"{innerType}?";

    public string ArrayType(string innerType) => $"IonArray<{innerType}>";

    public string GenericType(string baseName, IEnumerable<string> typeArgs)
        => $"{baseName}<{string.Join(", ", typeArgs)}>";

    public string AsyncReturnType(string? innerType)
        => innerType == null ? "Task" : $"Task<{innerType}>";

    public string StreamReturnType(string innerType)
        => $"IAsyncEnumerable<{innerType}>";

    public string StreamInputType(string innerType)
        => $"IAsyncEnumerable<{innerType}>?";

    // ???????????????????????????????????????????????????????????????????
    // FORMATTING HELPERS
    // ???????????????????????????????????????????????????????????????????

    public string Indent(int level) => new(' ', level * 4);

    public string FormatIdentifier(string name)
    {
        // C# keywords that need escaping
        var keywords = new HashSet<string>
        {
            "abstract", "as", "base", "bool", "break", "byte", "case", "catch",
            "char", "checked", "class", "const", "continue", "decimal", "default",
            "delegate", "do", "double", "else", "enum", "event", "explicit",
            "extern", "false", "finally", "fixed", "float", "for", "foreach",
            "goto", "if", "implicit", "in", "int", "interface", "internal",
            "is", "lock", "long", "namespace", "new", "null", "object",
            "operator", "out", "override", "params", "private", "protected",
            "public", "readonly", "ref", "return", "sbyte", "sealed", "short",
            "sizeof", "stackalloc", "static", "string", "struct", "switch",
            "this", "throw", "true", "try", "typeof", "uint", "ulong",
            "unchecked", "unsafe", "ushort", "using", "virtual", "void",
            "volatile", "while"
        };

        return keywords.Contains(name) ? $"@{name}" : name;
    }

    public string FormatEnumValue(string value, int? bits = null)
    {
        // C# doesn't need special formatting for large integers
        return value;
    }

    private string FormatParameter(ParameterDecl p)
    {
        return $"{p.Type} {p.Name}";
    }
}
